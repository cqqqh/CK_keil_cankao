C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE FF
OBJECT MODULE PLACED IN ff.OBJ
COMPILER INVOKED BY: D:\Program Files\Keil\C51\BIN\C51.EXE ff.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*----------------------------------------------------------------------------/
   2          /  FatFs - FAT file system module  R0.07a                    (C)ChaN, 2009
   3          /-----------------------------------------------------------------------------/
   4          / FatFs module is an open source software to implement FAT file system to
   5          / small embedded systems. This is a free software and is opened for education,
   6          / research and commercial developments under license policy of following trems.
   7          /
   8          /  Copyright (C) 2009, ChaN, all right reserved.
   9          /
  10          / * The FatFs module is a free software and there is NO WARRANTY.
  11          / * No restriction on use. You can use, modify and redistribute it for
  12          /   personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
  13          / * Redistributions of source code must retain the above copyright notice.
  14          //-----------------------------------------------------------------------------/
  15          / Feb 26,'06 R0.00  Prototype.
  16          /
  17          / Apr 29,'06 R0.01  First stable version.
  18          /
  19          / Jun 01,'06 R0.02  Added FAT12 support.
  20          /                   Removed unbuffered mode.
  21          /                   Fixed a problem on small (<32M) patition.
  22          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
  23          /
  24          / Sep 22,'06 R0.03  Added f_rename().
  25          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
  26          / Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
  27          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
  28          /
  29          / Feb 04,'07 R0.04  Supported multiple drive system.
  30          /                   Changed some interfaces for multiple drive system.
  31          /                   Changed f_mountdrv() to f_mount().
  32          /                   Added f_mkfs().
  33          / Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
  34          /                   Added a capability of extending file size to f_lseek().
  35          /                   Added minimization level 3.
  36          /                   Fixed an endian sensitive code in f_mkfs().
  37          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
  38          /                   Added FSInfo support.
  39          /                   Fixed DBCS name can result FR_INVALID_NAME.
  40          /                   Fixed short seek (<= csize) collapses the file object.
  41          /
  42          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
  43          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
  44          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
  45          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
  46          /                   Fixed off by one error at FAT sub-type determination.
  47          /                   Fixed btr in f_read() can be mistruncated.
  48          /                   Fixed cached sector is not flushed when create and close
  49          /                   without write.
  50          /
  51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
  52          /                   Improved performance of f_lseek() on moving to the same
  53          /                   or following cluster.
  54          /
  55          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a buffer configuration option.
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 2   

  56          /                   Added long file name support.
  57          /                   Added multiple code page support.
  58          /                   Added re-entrancy for multitask operation.
  59          /                   Added auto cluster size selection to f_mkfs().
  60          /                   Added rewind option to f_readdir().
  61          /                   Changed result code of critical errors.
  62          /                   Renamed string functions to avoid name collision.
  63          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
  64          /                   Added multiple sector size support.
  65          /---------------------------------------------------------------------------*/
  66          
  67          #include "ff.h"                 /* FatFs configurations and declarations */
*** WARNING C322 IN LINE 302 OF ff.h: unknown identifier
*** WARNING C322 IN LINE 308 OF ff.h: unknown identifier
  68          #include "diskio.h"             /* Declarations of low level disk I/O functions */
  69          
  70          
  71          /*--------------------------------------------------------------------------
  72          
  73             Module Private Definitions
  74          
  75          ---------------------------------------------------------------------------*/
  76          
  77          #if _FS_REENTRANT
              #if _USE_LFN == 1
              #error Static LFN work area must not be used in re-entrant configuration.
              #endif
              #define ENTER_FF(fs)            { if (!lock_fs(fs)) return FR_TIMEOUT; }
              #define LEAVE_FF(fs, res)       { unlock_fs(fs, res); return res; }
              
              #else
  85          #define ENTER_FF(fs)
  86          #define LEAVE_FF(fs, res)       return res
  87          
  88          #endif
  89          
  90          #define ABORT(fs, res)          { fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
  91          
  92          #ifndef NULL
  93          #define NULL    0
  94          #endif
  95          
  96          
  97          /*--------------------------------------------------------------------------
  98          
  99             Private Work Area
 100          
 101          ---------------------------------------------------------------------------*/
 102          
 103          static
 104          FATFS *FatFs[_DRIVES];  /* Pointer to the file system objects (logical drives) */
 105          static
 106          WORD Fsid;                              /* File system mount ID */
 107          
 108          
 109          #if _USE_LFN == 1       /* LFN with static LFN working buffer */
              static
              WORD LfnBuf[_MAX_LFN + 1];
              #define NAMEBUF(sp,lp)  BYTE sp[12]; WCHAR *lp = LfnBuf
              #define INITBUF(dj,sp,lp)       dj.fn = sp; dj.lfn = lp
              
              #elif _USE_LFN > 1      /* LFN with dynamic LFN working buffer */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 3   

              #define NAMEBUF(sp,lp)  BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf
              #define INITBUF(dj,sp,lp)       dj.fn = sp; dj.lfn = lp
              
              #else                           /* No LFN */
 120          #define NAMEBUF(sp,lp)  BYTE sp[12]
 121          #define INITBUF(dj,sp,lp)       dj.fn = sp
 122          
 123          #endif
 124          
 125          
 126          
 127          
 128          /*--------------------------------------------------------------------------
 129          
 130             Private Functions
 131          
 132          ---------------------------------------------------------------------------*/
 133          
 134          
 135          /*-----------------------------------------------------------------------*/
 136          /* String functions                                                      */
 137          /*-----------------------------------------------------------------------*/
 138          
 139          /* Copy memory to memory */
 140          static
 141          void mem_cpy (void* dst, const void* src, int cnt) {
 142   1              char *d = (char*)dst;
 143   1              const char *s = (const char *)src;
 144   1              while (cnt--) *d++ = *s++;
 145   1      }
 146          
 147          /* Fill memory */
 148          static
 149          void mem_set (void* dst, int val, int cnt) {
 150   1              char *d = (char*)dst;
 151   1              while (cnt--) *d++ = (char)val;
 152   1      }
 153          
 154          /* Compare memory to memory */
 155          static
 156          int mem_cmp (const void* dst, const void* src, int cnt) {
 157   1              const char *d = (const char *)dst, *s = (const char *)src;
 158   1              int r = 0;
 159   1              while (cnt-- && (r = *d++ - *s++) == 0) ;
 160   1              return r;
 161   1      }
 162          
 163          /* Check if chr is contained in the string */
 164          static
 165          int chk_chr (const char* str, int chr) {
 166   1              while (*str && *str != chr) str++;
 167   1              return *str;
 168   1      }
 169          
 170          
 171          
 172          /*-----------------------------------------------------------------------*/
 173          /* Request/Release grant to access the volume                            */
 174          /*-----------------------------------------------------------------------*/
 175          #if _FS_REENTRANT
              
              static
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 4   

              BOOL lock_fs (
                      FATFS *fs               /* File system object */
              )
              {
                      return ff_req_grant(fs->sobj);
              }
              
              
              static
              void unlock_fs (
                      FATFS *fs,              /* File system object */
                      FRESULT res             /* Result code to be returned */
              )
              {
                      if (res != FR_NOT_ENABLED &&
                              res != FR_INVALID_DRIVE &&
                              res != FR_INVALID_OBJECT &&
                              res != FR_TIMEOUT) {
                              ff_rel_grant(fs->sobj);
                      }
              }
              #endif
 200          
 201          
 202          
 203          /*-----------------------------------------------------------------------*/
 204          /* Change window offset                                                  */
 205          /*-----------------------------------------------------------------------*/
 206          
 207          static
 208          FRESULT move_window (
 209                  FATFS *fs,              /* File system object */
 210                  DWORD sector    /* Sector number to make apperance in the fs->win[] */
 211          )                                       /* Move to zero only writes back dirty window */
 212          {
 213   1              DWORD wsect;
 214   1      
 215   1      
 216   1              wsect = fs->winsect;
 217   1              if (wsect != sector) {  /* Changed current window */
 218   2      #if !_FS_READONLY
 219   2                      if (fs->wflag) {        /* Write back dirty window if needed */
 220   3                              if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
 221   3                                      return FR_DISK_ERR;
 222   3                              fs->wflag = 0;
 223   3                              if (wsect < (fs->fatbase + fs->sects_fat)) {    /* In FAT area */
 224   4                                      BYTE nf;
 225   4                                      for (nf = fs->n_fats; nf >= 2; nf--) {  /* Refrect the change to FAT copy */
 226   5                                              wsect += fs->sects_fat;
 227   5                                              disk_write(fs->drive, fs->win, wsect, 1);
 228   5                                      }
 229   4                              }
 230   3                      }
 231   2      #endif
 232   2                      if (sector) {
 233   3                              if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
 234   3                                      return FR_DISK_ERR;
 235   3                              fs->winsect = sector;
 236   3                      }
 237   2              }
 238   1      
 239   1              return FR_OK;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 5   

 240   1      }
 241          
 242          
 243          
 244          
 245          /*-----------------------------------------------------------------------*/
 246          /* Clean-up cached data                                                  */
 247          /*-----------------------------------------------------------------------*/
 248          #if !_FS_READONLY
 249          static
 250          FRESULT sync (  /* FR_OK: successful, FR_DISK_ERR: failed */
 251                  FATFS *fs       /* File system object */
 252          )
 253          {
 254   1              FRESULT res;
 255   1      
 256   1      
 257   1              res = move_window(fs, 0);
 258   1              if (res == FR_OK) {
 259   2                      /* Update FSInfo sector if needed */
 260   2                      if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 261   3                              fs->winsect = 0;
 262   3                              mem_set(fs->win, 0, 512);
 263   3                              ST_WORD(fs->win+BS_55AA, 0xAA55);
 264   3                              ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 265   3                              ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 266   3                              ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 267   3                              ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 268   3                              disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 269   3                              fs->fsi_flag = 0;
 270   3                      }
 271   2                      /* Make sure that no pending write process in the physical drive */
 272   2                      if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
 273   2                              res = FR_DISK_ERR;
 274   2              }
 275   1      
 276   1              return res;
 277   1      }
 278          #endif
 279          
 280          
 281          
 282          
 283          /*-----------------------------------------------------------------------*/
 284          /* Get a cluster status                                                  */
 285          /*-----------------------------------------------------------------------*/
 286          
 287          static
 288          DWORD get_cluster (     /* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
 289                  FATFS *fs,              /* File system object */
 290                  DWORD clst              /* Cluster# to get the link information */
 291          )
 292          {
 293   1              WORD wc, bc;
 294   1              DWORD fsect;
 295   1      
 296   1      
 297   1              if (clst < 2 || clst >= fs->max_clust)  /* Check cluster address range */
 298   1                      return 1;
 299   1      
 300   1              fsect = fs->fatbase;
 301   1              switch (fs->fs_type) {
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 6   

 302   2              case FS_FAT12 :
 303   2                      bc = (WORD)clst * 3 / 2;
 304   2                      if (move_window(fs, fsect + (bc / SS(fs)))) break;
 305   2                      wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 306   2                      if (move_window(fs, fsect + (bc / SS(fs)))) break;
 307   2                      wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 308   2                      return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 309   2      
 310   2              case FS_FAT16 :
 311   2                      if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
 312   2                      return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 313   2      
 314   2              case FS_FAT32 :
 315   2                      if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
 316   2                      return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 317   2              }
 318   1      
 319   1              return 0xFFFFFFFF;      /* An error occured at the disk I/O layer */
 320   1      }
 321          
 322          
 323          
 324          
 325          /*-----------------------------------------------------------------------*/
 326          /* Change a cluster status                                               */
 327          /*-----------------------------------------------------------------------*/
 328          #if !_FS_READONLY
 329          static
 330          FRESULT put_cluster (
 331                  FATFS *fs,              /* File system object */
 332                  DWORD clst,             /* Cluster# to be changed (must be 2 to fs->max_clust-1) */
 333                  DWORD val               /* New value to mark the cluster */
 334          )
 335          {
 336   1              WORD bc;
 337   1              BYTE *p;
 338   1              DWORD fsect;
 339   1              FRESULT res;
 340   1      
 341   1      
 342   1              if (clst < 2 || clst >= fs->max_clust) {        /* Check cluster address range */
 343   2                      res = FR_INT_ERR;
 344   2      
 345   2              } else {
 346   2                      fsect = fs->fatbase;
 347   2                      switch (fs->fs_type) {
 348   3                      case FS_FAT12 :
 349   3                              bc = (WORD)clst * 3 / 2;
 350   3                              res = move_window(fs, fsect + (bc / SS(fs)));
 351   3                              if (res != FR_OK) break;
 352   3                              p = &fs->win[bc & (SS(fs) - 1)];
 353   3                              *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 354   3                              bc++;
 355   3                              fs->wflag = 1;
 356   3                              res = move_window(fs, fsect + (bc / SS(fs)));
 357   3                              if (res != FR_OK) break;
 358   3                              p = &fs->win[bc & (SS(fs) - 1)];
 359   3                              *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 360   3                              break;
 361   3      
 362   3                      case FS_FAT16 :
 363   3                              res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 7   

 364   3                              if (res != FR_OK) break;
 365   3                              ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
 366   3                              break;
 367   3      
 368   3                      case FS_FAT32 :
 369   3                              res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
 370   3                              if (res != FR_OK) break;
 371   3                              ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
 372   3                              break;
 373   3      
 374   3                      default :
 375   3                              res = FR_INT_ERR;
 376   3                      }
 377   2                      fs->wflag = 1;
 378   2              }
 379   1      
 380   1              return res;
 381   1      }
 382          #endif /* !_FS_READONLY */
 383          
 384          
 385          
 386          
 387          /*-----------------------------------------------------------------------*/
 388          /* Remove a cluster chain                                                */
 389          /*-----------------------------------------------------------------------*/
 390          #if !_FS_READONLY
 391          static
 392          FRESULT remove_chain (
 393                  FATFS *fs,                      /* File system object */
 394                  DWORD clst                      /* Cluster# to remove chain from */
 395          )
 396          {
 397   1              FRESULT res;
 398   1              DWORD nxt;
 399   1      
 400   1      
 401   1              if (clst < 2 || clst >= fs->max_clust) {        /* Check cluster address range */
 402   2                      res = FR_INT_ERR;
 403   2      
 404   2              } else {
 405   2                      res = FR_OK;
 406   2                      while (clst < fs->max_clust) {                  /* Not a last link? */
 407   3                              nxt = get_cluster(fs, clst);            /* Get cluster status */
 408   3                              if (nxt == 0) break;                            /* Empty cluster? */
 409   3                              if (nxt == 1) { res = FR_INT_ERR; break; }      /* Internal error? */
 410   3                              if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }    /* Disk error? */
 411   3                              res = put_cluster(fs, clst, 0);         /* Mark the cluster "empty" */
 412   3                              if (res != FR_OK) break;
 413   3                              if (fs->free_clust != 0xFFFFFFFF) {     /* Update FSInfo */
 414   4                                      fs->free_clust++;
 415   4                                      fs->fsi_flag = 1;
 416   4                              }
 417   3                              clst = nxt;     /* Next cluster */
 418   3                      }
 419   2              }
 420   1      
 421   1              return res;
 422   1      }
 423          #endif
 424          
 425          
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 8   

 426          
 427          
 428          /*-----------------------------------------------------------------------*/
 429          /* Stretch or create a cluster chain                                     */
 430          /*-----------------------------------------------------------------------*/
 431          #if !_FS_READONLY
 432          static
 433          DWORD create_chain (    /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
 434                  FATFS *fs,                      /* File system object */
 435                  DWORD clst                      /* Cluster# to stretch. 0 means create a new chain. */
 436          )
 437          {
 438   1              DWORD cs, ncl, scl, mcl;
 439   1      
 440   1      
 441   1              mcl = fs->max_clust;
 442   1              if (clst == 0) {                /* Create new chain */
 443   2                      scl = fs->last_clust;                   /* Get suggested start point */
 444   2                      if (scl == 0 || scl >= mcl) scl = 1;
 445   2              }
 446   1              else {                                  /* Stretch existing chain */
 447   2                      cs = get_cluster(fs, clst);             /* Check the cluster status */
 448   2                      if (cs < 2) return 1;                   /* It is an invalid cluster */
 449   2                      if (cs < mcl) return cs;                /* It is already followed by next cluster */
 450   2                      scl = clst;
 451   2              }
 452   1      
 453   1              ncl = scl;                              /* Start cluster */
 454   1              for (;;) {
 455   2                      ncl++;                                                  /* Next cluster */
 456   2                      if (ncl >= mcl) {                               /* Wrap around */
 457   3                              ncl = 2;
 458   3                              if (ncl > scl) return 0;        /* No free custer */
 459   3                      }
 460   2                      cs = get_cluster(fs, ncl);              /* Get the cluster status */
 461   2                      if (cs == 0) break;                             /* Found a free cluster */
 462   2                      if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
 463   2                              return cs;
 464   2                      if (ncl == scl) return 0;               /* No free custer */
 465   2              }
 466   1      
 467   1              if (put_cluster(fs, ncl, 0x0FFFFFFF))   /* Mark the new cluster "in use" */
 468   1                      return 0xFFFFFFFF;
 469   1              if (clst != 0) {                                                /* Link it to previous one if needed */
 470   2                      if (put_cluster(fs, clst, ncl))
 471   2                              return 0xFFFFFFFF;
 472   2              }
 473   1      
 474   1              fs->last_clust = ncl;                           /* Update FSINFO */
 475   1              if (fs->free_clust != 0xFFFFFFFF) {
 476   2                      fs->free_clust--;
 477   2                      fs->fsi_flag = 1;
 478   2              }
 479   1      
 480   1              return ncl;             /* Return new cluster number */
 481   1      }
 482          #endif /* !_FS_READONLY */
 483          
 484          
 485          
 486          
 487          /*-----------------------------------------------------------------------*/
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 9   

 488          /* Get sector# from cluster#                                             */
 489          /*-----------------------------------------------------------------------*/
 490          
 491          static
 492          DWORD clust2sect (      /* !=0: sector number, 0: failed - invalid cluster# */
 493                  FATFS *fs,              /* File system object */
 494                  DWORD clst              /* Cluster# to be converted */
 495          )
 496          {
 497   1              clst -= 2;
 498   1              if (clst >= (fs->max_clust - 2)) return 0;              /* Invalid cluster# */
 499   1              return clst * fs->csize + fs->database;
 500   1      }
 501          
 502          
 503          
 504          
 505          /*-----------------------------------------------------------------------*/
 506          /* Seek directory index                                                  */
 507          /*-----------------------------------------------------------------------*/
 508          
 509          static
 510          FRESULT dir_seek (
 511                  DIR *dj,                /* Pointer to directory object */
 512                  WORD idx                /* Directory index number */
 513          )
 514          {
 515   1              DWORD clst;
 516   1              WORD ic;
 517   1      
 518   1      
 519   1              dj->index = idx;
 520   1              clst = dj->sclust;
 521   1              if (clst == 1 || clst >= dj->fs->max_clust)     /* Check start cluster range */
 522   1                      return FR_INT_ERR;
 523   1      
 524   1              if (clst == 0) {        /* Static table */
 525   2                      if (idx >= dj->fs->n_rootdir)           /* Index is out of range */
 526   2                              return FR_INT_ERR;
 527   2                      dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);
 528   2              }
 529   1              else {                          /* Dynamic table */
 530   2                      ic = SS(dj->fs) / 32 * dj->fs->csize;   /* Indexes per cluster */
 531   2                      while (idx >= ic) {     /* Follow cluster chain */
 532   3                              clst = get_cluster(dj->fs, clst);                       /* Get next cluster */
 533   3                              if (clst == 0xFFFFFFFF) return FR_DISK_ERR;     /* Disk error */
 534   3                              if (clst < 2 || clst >= dj->fs->max_clust)      /* Reached to end of table or int error */
 535   3                                      return FR_INT_ERR;
 536   3                              idx -= ic;
 537   3                      }
 538   2                      dj->clust = clst;
 539   2                      dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);
 540   2              }
 541   1              dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;
 542   1      
 543   1              return FR_OK;   /* Seek succeeded */
 544   1      }
 545          
 546          
 547          
 548          
 549          /*-----------------------------------------------------------------------*/
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 10  

 550          /* Move directory index next                                             */
 551          /*-----------------------------------------------------------------------*/
 552          
 553          static
 554          FRESULT dir_next (      /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
 555                  DIR *dj,                /* Pointer to directory object */
 556                  BOOL streach    /* FALSE: Do not streach table, TRUE: Streach table if needed */
 557          )
 558          {
 559   1              DWORD clst;
 560   1              WORD i;
 561   1      
 562   1      
 563   1              i = dj->index + 1;
 564   1              if (!i || !dj->sect)    /* Report EOT when index has reached 65535 */
 565   1                      return FR_NO_FILE;
 566   1      
 567   1              if (!(i % (SS(dj->fs) / 32))) { /* Sector changed? */
 568   2                      dj->sect++;                                     /* Next sector */
 569   2      
 570   2                      if (dj->sclust == 0) {  /* Static table */
 571   3                              if (i >= dj->fs->n_rootdir)     /* Report EOT when end of table */
 572   3                                      return FR_NO_FILE;
 573   3                      }
 574   2                      else {                                  /* Dynamic table */
 575   3                              if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {     /* Cluster changed? */
 576   4                                      clst = get_cluster(dj->fs, dj->clust);                  /* Get next cluster */
 577   4                                      if (clst <= 1) return FR_INT_ERR;
 578   4                                      if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 579   4                                      if (clst >= dj->fs->max_clust) {                                /* When it reached end of dinamic table */
 580   5      #if !_FS_READONLY
 581   5                                              BYTE c;
 582   5                                              if (!streach) return FR_NO_FILE;                        /* When do not streach, report EOT */
 583   5                                              clst = create_chain(dj->fs, dj->clust);         /* Streach cluster chain */
 584   5                                              if (clst == 0) return FR_DENIED;                        /* No free cluster */
 585   5                                              if (clst == 1) return FR_INT_ERR;
 586   5                                              if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 587   5                                              /* Clean-up streached table */
 588   5                                              if (move_window(dj->fs, 0)) return FR_DISK_ERR; /* Flush active window */
 589   5                                              mem_set(dj->fs->win, 0, SS(dj->fs));                    /* Clear window buffer */
 590   5                                              dj->fs->winsect = clust2sect(dj->fs, clst);     /* Cluster start sector */
 591   5                                              for (c = 0; c < dj->fs->csize; c++) {           /* Fill the new cluster with 0 */
 592   6                                                      dj->fs->wflag = 1;
 593   6                                                      if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 594   6                                                      dj->fs->winsect++;
 595   6                                              }
 596   5                                              dj->fs->winsect -= c;                                           /* Rewind window address */
 597   5      #else
                                                      return FR_NO_FILE;                      /* Report EOT */
              #endif
 600   5                                      }
 601   4                                      dj->clust = clst;                               /* Initialize data for new cluster */
 602   4                                      dj->sect = clust2sect(dj->fs, clst);
 603   4                              }
 604   3                      }
 605   2              }
 606   1      
 607   1              dj->index = i;
 608   1              dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 609   1      
 610   1              return FR_OK;
 611   1      }
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 11  

 612          
 613          
 614          
 615          
 616          /*-----------------------------------------------------------------------*/
 617          /* Test/Pick/Fit an LFN segment from/to directory entry                  */
 618          /*-----------------------------------------------------------------------*/
 619          #if _USE_LFN
              static
              const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};      /* Offset of LFN chars in the directory entry *
             -/
              
              
              static
              BOOL test_lfn (                 /* TRUE:Matched, FALSE:Not matched */
                      WCHAR *lfnbuf,          /* Pointer to the LFN to be compared */
                      BYTE *dir                       /* Pointer to the directory entry containing a part of LFN */
              )
              {
                      int i, s;
                      WCHAR wc1, wc2;
              
              
                      i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;  /* Offset in the LFN buffer */
                      s = 0;
                      do {
                              if (i >= _MAX_LFN) return FALSE;        /* Out of buffer range? */
                              wc1 = LD_WORD(dir+LfnOfs[s]);           /* Get both characters to compare */
                              wc2 = lfnbuf[i++];
                              if (IsLower(wc1)) wc1 -= 0x20;          /* Compare it (ignore case) */
                              if (IsLower(wc2)) wc2 -= 0x20;
                              if (wc1 != wc2) return FALSE;
                      } while (++s < 13 && wc1);                              /* Repeat until last char or a NUL char is processed */
              
                      return TRUE;                                                    /* The LFN entry matched */
              }
              
              
              
              static
              BOOL pick_lfn (                 /* TRUE:Succeeded, FALSE:Buffer overflow */
                      WCHAR *lfnbuf,          /* Pointer to the Unicode-LFN buffer */
                      BYTE *dir                       /* Pointer to the directory entry */
              )
              {
                      int i, s;
                      WCHAR wchr;
              
              
                      i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;  /* Offset in the LFN buffer */
                      s = 0;
                      do {
                              wchr = LD_WORD(dir+LfnOfs[s]);          /* Get an LFN char */
                              if (!wchr) break;                                       /* End of LFN? */
                              if (i >= _MAX_LFN) return FALSE;        /* Buffer overflow */
                              lfnbuf[i++] = wchr;                                     /* Store it */
                      } while (++s < 13);                                             /* Repeat until last char is copied */
                      if (dir[LDIR_Ord] & 0x40) lfnbuf[i] = 0;        /* Put terminator if last LFN entry */
              
                      return TRUE;
              }
              
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 12  

              
              #if !_FS_READONLY
              static
              void fit_lfn (
                      const WCHAR *lfnbuf,    /* Pointer to the LFN buffer */
                      BYTE *dir,                              /* Pointer to the directory entry */
                      BYTE ord,                               /* LFN order (1-20) */
                      BYTE sum                                /* SFN sum */
              )
              {
                      int i, s;
                      WCHAR wchr;
              
              
                      dir[LDIR_Chksum] = sum;                 /* Set check sum */
                      dir[LDIR_Attr] = AM_LFN;                /* Set attribute. LFN entry */
                      dir[LDIR_Type] = 0;
                      ST_WORD(dir+LDIR_FstClusLO, 0);
              
                      i = (ord - 1) * 13;                             /* Offset in the LFN buffer */
                      s = wchr = 0;
                      do {
                              if (wchr != 0xFFFF) wchr = lfnbuf[i++]; /* Get an effective char */
                              ST_WORD(dir+LfnOfs[s], wchr);   /* Put it */
                              if (!wchr) wchr = 0xFFFF;       /* Padding chars following last char */
                      } while (++s < 13);
                      if (wchr == 0xFFFF || !lfnbuf[i]) ord |= 0x40;/* Bottom LFN part is the start of LFN sequence */
                      dir[LDIR_Ord] = ord;                    /* Set the LFN order */
              }
              
              #endif
              #endif
 705          
 706          
 707          
 708          /*-----------------------------------------------------------------------*/
 709          /* Create numbered name                                                  */
 710          /*-----------------------------------------------------------------------*/
 711          #if _USE_LFN
              void gen_numname (
                      BYTE *dst,                      /* Pointer to genartated SFN */
                      const BYTE *src,        /* Pointer to source SFN to be modified */
                      const WCHAR *lfn,       /* Pointer to LFN */
                      WORD num                        /* Sequense number */
              )
              {
                      char ns[8];
                      int i, j;
              
              
                      mem_cpy(dst, src, 11);
              
                      if (num > 5) {  /* On many collisions, generate a hash number instead of sequencial number */
                              do num = (num >> 1) + (num << 15) + (WORD)*lfn++; while (*lfn);
                      }
              
                      /* itoa */
                      i = 7;
                      do {
                              ns[i--] = (num % 10) + '0';
                              num /= 10;
                      } while (num);
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 13  

                      ns[i] = '~';
              
                      /* Append the number */
                      for (j = 0; j < i && dst[j] != ' '; j++) {
                              if (IsDBCS1(dst[j])) {
                                      if (j == i - 1) break;
                                      j++;
                              }
                      }
                      do {
                              dst[j++] = (i < 8) ? ns[i++] : ' ';
                      } while (j < 8);
              }
              #endif
 749          
 750          
 751          
 752          
 753          /*-----------------------------------------------------------------------*/
 754          /* Calculate sum of an SFN                                               */
 755          /*-----------------------------------------------------------------------*/
 756          #if _USE_LFN
              static
              BYTE sum_sfn (
                      const BYTE *dir         /* Ptr to directory entry */
              )
              {
                      BYTE sum = 0;
                      int n = 11;
              
                      do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
                      return sum;
              }
              #endif
 769          
 770          
 771          
 772          
 773          /*-----------------------------------------------------------------------*/
 774          /* Find an object in the directory                                       */
 775          /*-----------------------------------------------------------------------*/
 776          
 777          static
 778          FRESULT dir_find (
 779                  DIR *dj                 /* Pointer to the directory object linked to the file name */
 780          )
 781          {
 782   1              FRESULT res;
 783   1              BYTE a, c, lfen, ord, sum, *dir;
 784   1      
 785   1      
 786   1              res = dir_seek(dj, 0);                  /* Rewind directory object */
 787   1              if (res != FR_OK) return res;
 788   1      
 789   1              ord = sum = 0xFF; lfen = *(dj->fn+11) & 1;
 790   1              do {
 791   2                      res = move_window(dj->fs, dj->sect);
 792   2                      if (res != FR_OK) break;
 793   2                      dir = dj->dir;                                  /* Ptr to the directory entry of current index */
 794   2                      c = dir[DIR_Name];
 795   2                      if (c == 0) { res = FR_NO_FILE; break; }        /* Reached to end of table */
 796   2                      a = dir[DIR_Attr] & AM_MASK;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 14  

 797   2      #if _USE_LFN    /* LFN configuration */
                              if (c == 0xE5 || c == '.' || ((a & AM_VOL) && a != AM_LFN)) {   /* An entry without valid data */
                                      ord = 0xFF;
                              } else {
                                      if (a == AM_LFN) {                      /* An LFN entry is found */
                                              if (dj->lfn) {
                                                      if (c & 0x40) {         /* Is it start of LFN sequence? */
                                                              sum = dir[LDIR_Chksum];
                                                              c &= 0xBF; ord = c;             /* LFN start order */
                                                              dj->lfn_idx = dj->index;
                                                      }
                                                      /* Check LFN validity. Compare LFN if it is out of 8.3 format */
                                                      ord = (c == ord && sum == dir[LDIR_Chksum] && (!lfen || test_lfn(dj->lfn, dir))) ? ord - 1 : 0xFF;
                                              }
                                      } else {                                        /* An SFN entry is found */
                                              if (ord || sum != sum_sfn(dir)) {       /* Did not LFN match? */
                                                      dj->lfn_idx = 0xFFFF;
                                                      ord = 0xFF;
                                              }
                                              if (lfen) {                             /* Match LFN if it is out of 8.3 format */
                                                      if (ord == 0) break;
                                              } else {                                /* Match SFN if LFN is in 8.3 format */
                                                      if (!mem_cmp(dir, dj->fn, 11)) break;
                                              }
                                      }
                              }
              #else   /* Non LFN configuration */
 824   2                      if (c != 0xE5 && c != '.' && !(a & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 825   2                              break;
 826   2      #endif
 827   2                      res = dir_next(dj, FALSE);                              /* Next entry */
 828   2              } while (res == FR_OK);
 829   1      
 830   1              return res;
 831   1      }
 832          
 833          
 834          
 835          
 836          /*-----------------------------------------------------------------------*/
 837          /* Read an object from the directory                                     */
 838          /*-----------------------------------------------------------------------*/
 839          #if _FS_MINIMIZE <= 2
 840          static
 841          FRESULT dir_read (
 842                  DIR *dj                 /* Pointer to the directory object to store read object name */
 843          )
 844          {
 845   1              FRESULT res;
 846   1              BYTE a, c, ord, sum, *dir;
 847   1      
 848   1      
 849   1              ord = sum = 0xFF;
 850   1              res = FR_NO_FILE;
 851   1              while (dj->sect) {
 852   2                      res = move_window(dj->fs, dj->sect);
 853   2                      if (res != FR_OK) break;
 854   2                      dir = dj->dir;                                  /* Ptr to the directory entry of current index */
 855   2                      c = dir[DIR_Name];
 856   2                      if (c == 0) { res = FR_NO_FILE; break; }        /* Reached to end of table */
 857   2                      a = dir[DIR_Attr] & AM_MASK;
 858   2      #if _USE_LFN    /* LFN configuration */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 15  

                              if (c == 0xE5 || c == '.' || ((a & AM_VOL) && a != AM_LFN)) {   /* An entry without valid data */
                                      ord = 0xFF;
                              } else {
                                      if (a == AM_LFN) {                      /* An LFN entry is found */
                                              if (c & 0x40) {                 /* Is it start of LFN sequence? */
                                                      sum = dir[LDIR_Chksum];
                                                      c &= 0xBF; ord = c;
                                                      dj->lfn_idx = dj->index;
                                              }
                                              /* Check LFN validity and capture it */
                                              ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
                                      } else {                                        /* An SFN entry is found */
                                              if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN entry? */
                                                      dj->lfn_idx = 0xFFFF;           /* No LFN. */
                                              break;
                                      }
                              }
              #else   /* Non LFN configuration */
 877   2                      if (c != 0xE5 && c != '.' && !(a & AM_VOL))     /* Is it a valid entry? */
 878   2                              break;
 879   2      #endif
 880   2                      res = dir_next(dj, FALSE);                              /* Next entry */
 881   2                      if (res != FR_OK) break;
 882   2              }
 883   1      
 884   1              if (res != FR_OK) dj->sect = 0;
 885   1      
 886   1              return res;
 887   1      }
 888          #endif
 889          
 890          
 891          
 892          /*-----------------------------------------------------------------------*/
 893          /* Register an object to the directory                                   */
 894          /*-----------------------------------------------------------------------*/
 895          #if !_FS_READONLY
 896          static
 897          FRESULT dir_register (  /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR
             -:Disk error */
 898                  DIR *dj                         /* Target directory with object name to be created */
 899          )
 900          {
 901   1              FRESULT res;
 902   1              BYTE c, *dir;
 903   1      
 904   1      #if _USE_LFN    /* LFN configuration */
                      WORD n, ne, is;
                      BYTE sn[12], *fn, sum;
                      WCHAR *lfn;
              
                      fn = dj->fn; lfn = dj->lfn;
                      mem_cpy(sn, fn, 12);
                      if (sn[11] & 1) {               /* When LFN is out of 8.3 format, generate a numbered name */
                              fn[11] = 0; dj->lfn = NULL;                     /* Find only SFN */
                              for (n = 1; n < 100; n++) {
                                      gen_numname(fn, sn, lfn, n);    /* Generate a numbered name */
                                      res = dir_find(dj);                             /* Check if the name collides with existing SFN */
                                      if (res != FR_OK) break;
                              }
                              if (n == 100) return FR_DENIED;         /* Abort if too many collisions */
                              if (res != FR_NO_FILE) return res;      /* Abort if the result is other than 'not collided' */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 16  

                              fn[11] = sn[11]; dj->lfn = lfn;
                      }
                      if (sn[11] & 2) {               /* When eliminate LFN, reserve only an SFN entry. */
                              ne = 1;
                      } else {                                /* Otherwise reserve an SFN + LFN entries. */
                              for (ne = 0; lfn[ne]; ne++) ;
                              ne = (ne + 25) / 13;
                      }
              
                      /* Reserve contiguous entries */
                      res = dir_seek(dj, 0);
                      if (res != FR_OK) return res;
                      n = is = 0;
                      do {
                              res = move_window(dj->fs, dj->sect);
                              if (res != FR_OK) break;
                              c = *dj->dir;   /* Check the entry status */
                              if (c == 0xE5 || c == 0) {      /* Is it a blank entry? */
                                      if (n == 0) is = dj->index;     /* First index of the contigulus entry */
                                      if (++n == ne) break;   /* A contiguous entry that requiered count is found */
                              } else {
                                      n = 0;                                  /* Not a blank entry. Restart to search */
                              }
                              res = dir_next(dj, TRUE);       /* Next entry with table streach */
                      } while (res == FR_OK);
              
                      if (res == FR_OK && ne > 1) {   /* Initialize LFN entry if needed */
                              res = dir_seek(dj, is);
                              if (res == FR_OK) {
                                      sum = sum_sfn(dj->fn);  /* Sum of the SFN tied to the LFN */
                                      ne--;
                                      do {                                    /* Store LFN entries in bottom first */
                                              res = move_window(dj->fs, dj->sect);
                                              if (res != FR_OK) break;
                                              fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
                                              dj->fs->wflag = 1;
                                              res = dir_next(dj, FALSE);      /* Next entry */
                                      } while (res == FR_OK && --ne);
                              }
                      }
              
              #else   /* Non LFN configuration */
 962   1              res = dir_seek(dj, 0);
 963   1              if (res == FR_OK) {
 964   2                      do {    /* Find a blank entry for the SFN */
 965   3                              res = move_window(dj->fs, dj->sect);
 966   3                              if (res != FR_OK) break;
 967   3                              c = *dj->dir;
 968   3                              if (c == 0xE5 || c == 0) break; /* Is it a blank entry? */
 969   3                              res = dir_next(dj, TRUE);               /* Next entry with table streach */
 970   3                      } while (res == FR_OK);
 971   2              }
 972   1      #endif
 973   1      
 974   1              if (res == FR_OK) {             /* Initialize the SFN entry */
 975   2                      res = move_window(dj->fs, dj->sect);
 976   2                      if (res == FR_OK) {
 977   3                              dir = dj->dir;
 978   3                              mem_set(dir, 0, 32);                    /* Clean the entry */
 979   3                              mem_cpy(dir, dj->fn, 11);       /* Put SFN */
 980   3                              dir[DIR_NTres] = *(dj->fn+11) & 0x18;   /* Put NT flag */
 981   3                              dj->fs->wflag = 1;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 17  

 982   3                      }
 983   2              }
 984   1      
 985   1              return res;
 986   1      }
 987          #endif /* !_FS_READONLY */
 988          
 989          
 990          
 991          
 992          /*-----------------------------------------------------------------------*/
 993          /* Remove an object from the directory                                   */
 994          /*-----------------------------------------------------------------------*/
 995          #if !_FS_READONLY && !_FS_MINIMIZE
 996          static
 997          FRESULT dir_remove (    /* FR_OK: Successful, FR_DISK_ERR: A disk error */
 998                  DIR *dj                         /* Directory object pointing the entry to be removed */
 999          )
1000          {
1001   1              FRESULT res;
1002   1      
1003   1      #if _USE_LFN    /* LFN configuration */
                      WORD i;
              
                      i = dj->index;  /* SFN index */
                      res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));  /* Goto the SFN or top of the LFN 
             -entries */
                      if (res == FR_OK) {
                              do {
                                      res = move_window(dj->fs, dj->sect);
                                      if (res != FR_OK) break;
                                      *dj->dir = 0xE5;                                /* Mark the entry "deleted" */
                                      dj->fs->wflag = 1;
                                      if (dj->index >= i) break;              /* When SFN is deleted, all entries of the object is deleted. */
                                      res = dir_next(dj, FALSE);              /* Next entry */
                              } while (res == FR_OK);
                              if (res == FR_NO_FILE) res = FR_INT_ERR;
                      }
              
              #else                   /* Non LFN configuration */
1021   1              res = dir_seek(dj, dj->index);
1022   1              if (res == FR_OK) {
1023   2                      res = move_window(dj->fs, dj->sect);
1024   2                      if (res == FR_OK) {
1025   3                              *dj->dir = 0xE5;                                /* Mark the entry "deleted" */
1026   3                              dj->fs->wflag = 1;
1027   3                      }
1028   2              }
1029   1      #endif
1030   1      
1031   1              return res;
1032   1      }
1033          #endif /* !_FS_READONLY */
1034          
1035          
1036          
1037          
1038          /*-----------------------------------------------------------------------*/
1039          /* Pick a segment and create the object name in directory form           */
1040          /*-----------------------------------------------------------------------*/
1041          
1042          static
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 18  

1043          FRESULT create_name (
1044                  DIR *dj,                        /* Pointer to the directory object */
1045                  const char **path       /* Pointer to pointer to the segment in the path string */
1046          )
1047          {
1048   1      #if _USE_LFN
                      BYTE c, b, cf, *sfn;
                      WCHAR w, *lfn;
                      int i, ni, si, di;
                      const char *p;
              
                      /* Create LFN in Unicode */
                      si = di = 0;
                      p = *path;
                      lfn = dj->lfn;
                      for (;;) {
                              w = (BYTE)p[si++];                              /* Get a character */
                              if (w < ' ' || w == '/' || w == '\\') break;    /* Break on end of segment */
                              if (IsDBCS1(w)) {                               /* If it is DBC 1st byte */
                                      c = p[si++];                            /* Get 2nd byte */
                                      if (!IsDBCS2(c))                        /* Reject invalid DBC */
                                              return FR_INVALID_NAME;
                                      w = (w << 8) + c;
                              } else {
                                      if (chk_chr("\"*:<>\?|\x7F", w))        /* Reject unallowable chars for LFN */
                                              return FR_INVALID_NAME;
                              }
                              w = ff_convert(w, 1);                   /* Convert OEM to Unicode, store it */
                              if (!w || di >= _MAX_LFN)               /* Reject invalid code or too long name */
                                      return FR_INVALID_NAME;
                              lfn[di++] = w;
                      }
                      *path = &p[si];                                         /* Rerurn pointer to the next segment */
                      cf = (w < ' ') ? 4 : 0;                         /* Set last segment flag if end of path */
              
                      while (di) {                                            /* Strip trailing spaces and dots */
                              w = lfn[di - 1];
                              if (w != ' ' && w != '.') break;
                              di--;
                      }
                      if (!di) return FR_INVALID_NAME;        /* Reject null string */
              
                      lfn[di] = 0;                                            /* LFN is created */
              
                      /* Create SFN in directory form */
                      sfn = dj->fn;
                      mem_set(sfn, ' ', 11);
                      for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;  /* Strip leading spaces and dots */
                      if (si) cf |= 1;
                      while (di && lfn[di - 1] != '.') di--;  /* Find extension (di<=si: no extension) */
              
                      b = i = 0; ni = 8;
                      for (;;) {
                              w = lfn[si++];                                  /* Get an LFN char */
                              if (w == 0) break;                              /* Break when enf of the LFN */
                              if (w == ' ' || (w == '.' && si != di)) {       /* Remove spaces and dots */
                                      cf |= 1; continue;
                              }
                              if (i >= ni || si == di) {              /* Here is extension or end of SFN */
                                      if (ni == 11) {                         /* Extension is longer than 3 bytes */
                                              cf |= 1; break;
                                      }
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 19  

                                      if (si != di) cf |= 1;          /* File name is longer than 8 bytes */
                                      if (si > di) break;                     /* No extension */
                                      si = di; i = 8; ni = 11;        /* Enter extension section */
                                      b <<= 2; continue;
                              }
                              w = ff_convert(w, 0);                   /* Unicode -> OEM code */
                              if (w >= 0x80) cf |= 0x20;              /* If there is any extended char, force create an LFN */
                              if (w >= 0x100) {                               /* Double byte char */
                                      if (i >= ni - 1) {
                                              cf |= 1; i = ni; continue;
                                      }
                                      sfn[i++] = (BYTE)(w >> 8);
                              } else {                                                /* Single byte char */
                                      if (chk_chr("+,;[=]", w)) {     /* Replace unallowable chars for SFN */
                                              w = '_'; cf |= 1;
                                      } else {
                                              if (IsUpper(w)) {               /* Large capital */
                                                      b |= 2;
                                              } else {
                                                      if (IsLower(w)) {       /* Small capital */
                                                              b |= 1; w -= 0x20;
                                                      }
                                              }
                                      }
                              }
                              sfn[i++] = (BYTE)w;
                      }
                      if (sfn[0] == 0xE5) sfn[0] = 0x05;      /* When first char collides with 0xE5, replace it with 0x05 */
              
                      if (ni == 8) b <<= 2;
                      if ((cf & 0x21) == 0) { /* When LFN is in 8.3 format without extended char, NT flags are created */
                              if ((b & 0x03) == 0x01) cf |= 0x10;     /* NT flag (Extension has only small capital) */
                              if ((b & 0x0C) == 0x04) cf |= 0x08;     /* NT flag (Filename has only small capital) */
                              if ((b & 0x0C) != 0x0C && (b & 0x03) != 0x03) cf |= 2;  /* Eliminate LFN when non composite capitals */
                      }
              
                      sfn[11] = cf;           /* SFN is created */
              
              #else
1144   1              BYTE c, d, b, *sfn;
1145   1              int ni, si, i;
1146   1              const char *p;
1147   1      
1148   1              /* Create file name in directory form */
1149   1              sfn = dj->fn;
1150   1              mem_set(sfn, ' ', 11);
1151   1              si = i = b = 0; ni = 8;
1152   1              p = *path;
1153   1              for (;;) {
1154   2                      c = p[si++];
1155   2                      if (c < ' ' || c == '/' || c == '\\') break;    /* Break on end of segment */
1156   2                      if (c == '.' || i >= ni) {
1157   3                              if (ni != 8 || c != '.') return FR_INVALID_NAME;
1158   3                              i = 8; ni = 11;
1159   3                              b <<= 2; continue;
1160   3                      }
1161   2                      if (c >= 0x80) b |= 3;                  /* If there is any extended char, eliminate NT flag */
1162   2                      if (IsDBCS1(c)) {                               /* If it is DBC 1st byte */
1163   3                              d = p[si++];                            /* Get 2nd byte */
1164   3                              if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
1165   3                                      return FR_INVALID_NAME;
1166   3                              sfn[i++] = c;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 20  

1167   3                              sfn[i++] = d;
1168   3                      } else {
1169   3                              if (chk_chr(" +,;[=]\"*:<>\?|\x7F", c)) /* Reject unallowable chrs for SFN */
1170   3                                      return FR_INVALID_NAME;
1171   3                              if (IsUpper(c)) {
1172   4                                      b |= 2;
1173   4                              } else {
1174   4                                      if (IsLower(c)) {
1175   5                                              b |= 1; c -= 0x20;
1176   5                                      }
1177   4                              }
1178   3                              sfn[i++] = c;
1179   3                      }
1180   2              }
1181   1              *path = &p[si];                                         /* Rerurn pointer to the next segment */
1182   1              c = (c < ' ') ? 4 : 0;                          /* Set last segment flag if end of path */
1183   1      
1184   1              if (!i) return FR_INVALID_NAME;         /* Reject null string */
1185   1              if (sfn[0] == 0xE5) sfn[0] = 0x05;      /* When first char collides with 0xE5, replace it with 0x05 */
1186   1      
1187   1              if (ni == 8) b <<= 2;
1188   1              if ((b & 0x03) == 0x01) c |= 0x10;      /* NT flag (Extension has only small capital) */
1189   1              if ((b & 0x0C) == 0x04) c |= 0x08;      /* NT flag (Filename has only small capital) */
1190   1      
1191   1              sfn[11] = c;            /* Store NT flag, File name is created */
1192   1      #endif
1193   1      
1194   1              return FR_OK;
1195   1      }
1196          
1197          
1198          
1199          
1200          /*-----------------------------------------------------------------------*/
1201          /* Get file information from directory entry                             */
1202          /*-----------------------------------------------------------------------*/
1203          #if _FS_MINIMIZE <= 1
1204          static
1205          void get_fileinfo (             /* No return code */
1206                  DIR *dj,                        /* Pointer to the directory object */
1207                  FILINFO *fno            /* Pointer to store the file information */
1208          )
1209          {
1210   1              int i;
1211   1              BYTE c, nt, *dir;
1212   1              char *p;
1213   1      
1214   1      
1215   1              p = fno->fname;
1216   1              if (dj->sect) {
1217   2                      dir = dj->dir;
1218   2                      nt = dir[DIR_NTres];            /* NT flag */
1219   2                      for (i = 0; i < 8; i++) {       /* Copy file name body */
1220   3                              c = dir[i];
1221   3                              if (c == ' ') break;
1222   3                              if (c == 0x05) c = 0xE5;
1223   3                              if ((nt & 0x08) && IsUpper(c)) c += 0x20;
1224   3                              *p++ = c;
1225   3                      }
1226   2                      if (dir[8] != ' ') {            /* Copy file name extension */
1227   3                              *p++ = '.';
1228   3                              for (i = 8; i < 11; i++) {
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 21  

1229   4                                      c = dir[i];
1230   4                                      if (c == ' ') break;
1231   4                                      if ((nt & 0x10) && IsUpper(c)) c += 0x20;
1232   4                                      *p++ = c;
1233   4                              }
1234   3                      }
1235   2                      fno->fattrib = dir[DIR_Attr];                           /* Attribute */
1236   2                      fno->fsize = LD_DWORD(dir+DIR_FileSize);        /* Size */
1237   2                      fno->fdate = LD_WORD(dir+DIR_WrtDate);          /* Date */
1238   2                      fno->ftime = LD_WORD(dir+DIR_WrtTime);          /* Time */
1239   2              }
1240   1              *p = 0;
1241   1      
1242   1      #if _USE_LFN
                      p = fno->lfname;
                      if (p) {
                              WCHAR wchr, *lfn;
              
                              i = 0;
                              if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
                                      lfn = dj->lfn;
                                      while ((wchr = *lfn++) != 0) {          /* Get an LFN char */
                                              wchr = ff_convert(wchr, 0);             /* Unicode -> OEM code */
                                              if (!wchr) { i = 0; break; }    /* Conversion error, no LFN */
                                              if (_DF1S && wchr >= 0x100)             /* Put 1st byte if it is a DBC */
                                                      p[i++] = (char)(wchr >> 8);
                                              p[i++] = (char)wchr;
                                              if (i >= fno->lfsize) { i = 0; break; } /* Buffer overrun, no LFN */
                                      }
                              }
                              p[i] = 0;       /* Terminator */
                      }
              #endif
1262   1      }
1263          #endif /* _FS_MINIMIZE <= 1 */
1264          
1265          
1266          
1267          
1268          /*-----------------------------------------------------------------------*/
1269          /* Follow a file path                                                    */
1270          /*-----------------------------------------------------------------------*/
1271          
1272          static
1273          FRESULT follow_path (   /* FR_OK(0): successful, !=0: error code */
1274                  DIR *dj,                        /* Directory object to return last directory and found object */
1275                  const char *path        /* Full-path string to find a file or directory */
1276          )
1277          {
1278   1              FRESULT res;
1279   1              BYTE *dir, last;
1280   1      
1281   1      
1282   1              if (*path == '/' || *path == '\\' ) path++;     /* Strip heading separator */
1283   1      
1284   1              dj->sclust =                                            /* Set start directory (root dir) */
1285   1                      (dj->fs->fs_type == FS_FAT32) ? dj->fs->dirbase : 0;
1286   1      
1287   1              if ((BYTE)*path < ' ') {                        /* Null path means the root directory */
1288   2                      res = dir_seek(dj, 0);
1289   2                      dj->dir = NULL;
1290   2      
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 22  

1291   2              } else {                                                        /* Follow path */
1292   2                      for (;;) {
1293   3                              res = create_name(dj, &path);   /* Get a segment */
1294   3                              if (res != FR_OK) break;
1295   3                              res = dir_find(dj);                             /* Find it */
1296   3                              last = *(dj->fn+11) & 4;
1297   3                              if (res != FR_OK) {                             /* Could not find the object */
1298   4                                      if (res == FR_NO_FILE && !last)
1299   4                                              res = FR_NO_PATH;
1300   4                                      break;
1301   4                              }
1302   3                              if (last) break;                                /* Last segment match. Function completed. */
1303   3                              dir = dj->dir;                                  /* There is next segment. Follow the sub directory */
1304   3                              if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
1305   4                                      res = FR_NO_PATH; break;
1306   4                              }
1307   3                              dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
1308   3                      }
1309   2              }
1310   1      
1311   1              return res;
1312   1      }
1313          
1314          
1315          
1316          
1317          /*-----------------------------------------------------------------------*/
1318          /* Load boot record and check if it is an FAT boot record                */
1319          /*-----------------------------------------------------------------------*/
1320          
1321          static
1322          BYTE check_fs ( /* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error
             - */
1323                  FATFS *fs,      /* File system object */
1324                  DWORD sect      /* Sector# (lba) to check if it is an FAT boot record or not */
1325          )
1326          {
1327   1              if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)   /* Load boot record */
1328   1                      return 3;
1329   1              if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)                               /* Check record signature (always placed at offset 510 even 
             -if the sector size is >512) */
1330   1                      return 2;
1331   1      
1332   1              if (!mem_cmp(&fs->win[BS_FilSysType], "FAT", 3))                /* Check FAT signature */
1333   1                      return 0;
1334   1              if (!mem_cmp(&fs->win[BS_FilSysType32], "FAT32", 5) && !(fs->win[BPB_ExtFlags] & 0x80))
1335   1                      return 0;
1336   1      
1337   1              return 1;
1338   1      }
1339          
1340          
1341          
1342          
1343          /*-----------------------------------------------------------------------*/
1344          /* Make sure that the file system is valid                               */
1345          /*-----------------------------------------------------------------------*/
1346          
1347          static
1348          FRESULT auto_mount (    /* FR_OK(0): successful, !=0: any error occured */
1349                  const char **path,      /* Pointer to pointer to the path name (drive number) */
1350                  FATFS **rfs,            /* Pointer to pointer to the found file system object */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 23  

1351                  BYTE chk_wp                     /* !=0: Check media write protection for write access */
1352          )
1353          {
1354   1              FRESULT res;
1355   1              BYTE vol, fmt, *tbl;
1356   1              DSTATUS stat;
1357   1              DWORD bsect, fsize, tsect, mclst;
1358   1              const char *p = *path;
1359   1              FATFS *fs;
1360   1      
1361   1      
1362   1              /* Get logical drive number from the path name */
1363   1              vol = p[0] - '0';                       /* Is there a drive number? */
1364   1              if (vol <= 9 && p[1] == ':') {
1365   2                      p += 2;                                 /* Found a drive number, get and strip it */
1366   2                      *path = p;                              /* Return pointer to the path name */
1367   2              } else {
1368   2                      vol = 0;                                /* No drive number is given, use drive number 0 as default */
1369   2              }
1370   1      
1371   1              /* Check if the logical drive number is valid or not */
1372   1              if (vol >= _DRIVES) return FR_INVALID_DRIVE;    /* Is the drive number valid? */
1373   1              *rfs = fs = FatFs[vol];                                 /* Returen pointer to the corresponding file system object */
1374   1              if (!fs) return FR_NOT_ENABLED;                 /* Is the file system object registered? */
1375   1      
1376   1              ENTER_FF(fs);                           /* Lock file system */
1377   1      
1378   1              if (fs->fs_type) {                                              /* If the logical drive has been mounted */
1379   2                      stat = disk_status(fs->drive);
1380   2                      if (!(stat & STA_NOINIT)) {                     /* and physical drive is kept initialized (has not been changed), */
1381   3      #if !_FS_READONLY
1382   3                              if (chk_wp && (stat & STA_PROTECT))     /* Check write protection if needed */
1383   3                                      return FR_WRITE_PROTECTED;
1384   3      #endif
1385   3                              return FR_OK;                                   /* The file system object is valid */
1386   3                      }
1387   2              }
1388   1      
1389   1              /* The logical drive must be re-mounted. Following code attempts to mount the volume */
1390   1      
1391   1              fs->fs_type = 0;                                        /* Clear the file system object */
1392   1              fs->drive = LD2PD(vol);                         /* Bind the logical drive and a physical drive */
1393   1              stat = disk_initialize(fs->drive);      /* Initialize low level disk I/O layer */
1394   1              if (stat & STA_NOINIT)                          /* Check if the drive is ready */
1395   1                      return FR_NOT_READY;
1396   1      #if _MAX_SS != 512                                              /* Get disk sector size if needed */
                      if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
                              return FR_NO_FILESYSTEM;
              #endif
1400   1      #if !_FS_READONLY
1401   1              if (chk_wp && (stat & STA_PROTECT))     /* Check write protection if needed */
1402   1                      return FR_WRITE_PROTECTED;
1403   1      #endif
1404   1              /* Search FAT partition on the drive */
1405   1              fmt = check_fs(fs, bsect = 0);          /* Check sector 0 as an SFD format */
1406   1              if (fmt == 1) {                                         /* Not an FAT boot record, it may be patitioned */
1407   2                      /* Check a partition listed in top of the partition table */
1408   2                      tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];    /* Partition table */
1409   2                      if (tbl[4]) {                                                                   /* Is the partition existing? */
1410   3                              bsect = LD_DWORD(&tbl[8]);                                      /* Partition offset in LBA */
1411   3                              fmt = check_fs(fs, bsect);                                      /* Check the partition */
1412   3                      }
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 24  

1413   2              }
1414   1              if (fmt == 3) return FR_DISK_ERR;
1415   1              if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))   /* No valid FAT patition is found */
1416   1                      return FR_NO_FILESYSTEM;
1417   1      
1418   1              /* Initialize the file system object */
1419   1              fsize = LD_WORD(fs->win+BPB_FATSz16);                           /* Number of sectors per FAT */
1420   1              if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
1421   1              fs->sects_fat = fsize;
1422   1              fs->n_fats = fs->win[BPB_NumFATs];                                      /* Number of FAT copies */
1423   1              fsize *= fs->n_fats;                                                            /* (Number of sectors in FAT area) */
1424   1              fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
1425   1              fs->csize = fs->win[BPB_SecPerClus];                            /* Number of sectors per cluster */
1426   1              fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);        /* Nmuber of root directory entries */
1427   1              tsect = LD_WORD(fs->win+BPB_TotSec16);                          /* Number of sectors on the file system */
1428   1              if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
1429   1              fs->max_clust = mclst = (tsect                                          /* Last cluster# + 1 */
1430   1                      - LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
1431   1                      ) / fs->csize + 2;
1432   1      
1433   1              fmt = FS_FAT12;                                                                         /* Determine the FAT sub type */
1434   1              if (mclst >= 0xFF7) fmt = FS_FAT16;                             /* Number of clusters >= 0xFF5 */
1435   1              if (mclst >= 0xFFF7) fmt = FS_FAT32;                    /* Number of clusters >= 0xFFF5 */
1436   1      
1437   1              if (fmt == FS_FAT32)
1438   1                      fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);   /* Root directory start cluster */
1439   1              else
1440   1                      fs->dirbase = fs->fatbase + fsize;                              /* Root directory start sector (lba) */
1441   1              fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);       /* Data start sector (lba) */
1442   1      
1443   1      #if !_FS_READONLY
1444   1              /* Initialize allocation information */
1445   1              fs->free_clust = 0xFFFFFFFF;
1446   1              fs->wflag = 0;
1447   1              /* Get fsinfo if needed */
1448   1              if (fmt == FS_FAT32) {
1449   2                      fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
1450   2                      fs->fsi_flag = 0;
1451   2                      if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
1452   2                              LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
1453   2                              LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
1454   2                              LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
1455   3                              fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
1456   3                              fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
1457   3                      }
1458   2              }
1459   1      #endif
1460   1              fs->winsect = 0;
1461   1              fs->fs_type = fmt;                      /* FAT syb-type */
1462   1              fs->id = ++Fsid;                        /* File system mount ID */
1463   1              res = FR_OK;
1464   1      
1465   1              return res;
1466   1      }
1467          
1468          
1469          
1470          
1471          /*-----------------------------------------------------------------------*/
1472          /* Check if the file/dir object is valid or not                          */
1473          /*-----------------------------------------------------------------------*/
1474          
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 25  

1475          static
1476          FRESULT validate (      /* FR_OK(0): The object is valid, !=0: Invalid */
1477                  FATFS *fs,              /* Pointer to the file system object */
1478                  WORD id                 /* Member id of the target object to be checked */
1479          )
1480          {
1481   1              if (!fs || !fs->fs_type || fs->id != id)
1482   1                      return FR_INVALID_OBJECT;
1483   1      
1484   1              ENTER_FF(fs);           /* Lock file system */
1485   1      
1486   1              if (disk_status(fs->drive) & STA_NOINIT)
1487   1                      return FR_NOT_READY;
1488   1      
1489   1              return FR_OK;
1490   1      }
1491          
1492          
1493          
1494          
1495          /*--------------------------------------------------------------------------
1496          
1497             Public Functions
1498          
1499          --------------------------------------------------------------------------*/
1500          
1501          
1502          
1503          /*-----------------------------------------------------------------------*/
1504          /* Mount/Unmount a Locical Drive                                         */
1505          /*-----------------------------------------------------------------------*/
1506          
1507          FRESULT f_mount (
1508                  BYTE vol,               /* Logical drive number to be mounted/unmounted */
1509                  FATFS *fs               /* Pointer to new file system object (NULL for unmount)*/
1510          )
1511          {
1512   1              FATFS *rfs;
1513   1      
1514   1      
1515   1              if (vol >= _DRIVES)                             /* Check if the drive number is valid */
1516   1                      return FR_INVALID_DRIVE;
1517   1              rfs = FatFs[vol];                               /* Get current state */
1518   1      
1519   1              if (rfs) {
1520   2      #if _FS_REENTRANT                                       /* Discard sync object of the current volume */
                              if (!ff_del_syncobj(fs->sobj)) return FR_INT_ERR;
              #endif
1523   2                      rfs->fs_type = 0;                       /* Clear old fs object */
1524   2              }
1525   1      
1526   1              if (fs) {
1527   2                      fs->fs_type = 0;                        /* Clear new fs object */
1528   2      #if _FS_REENTRANT                                       /* Create sync object for the new volume */
                              if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
              #endif
1531   2              }
1532   1              FatFs[vol] = fs;                                /* Register new fs object */
1533   1      
1534   1              return FR_OK;
1535   1      }
1536          
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 26  

1537          
1538          
1539          
1540          /*-----------------------------------------------------------------------*/
1541          /* Open or Create a File                                                 */
1542          /*-----------------------------------------------------------------------*/
1543          
1544          FRESULT f_open (
1545                  FIL *fp,                        /* Pointer to the blank file object */
1546                  const char *path,       /* Pointer to the file name */
1547                  BYTE mode                       /* Access mode and file open mode flags */
1548          )
1549          {
1550   1              FRESULT res;
1551   1              DIR dj;
1552   1              NAMEBUF(sfn, lfn);
1553   1              BYTE *dir;
1554   1      
1555   1      
1556   1              fp->fs = NULL;          /* Clear file object */
1557   1      #if !_FS_READONLY
1558   1              mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
1559   1              res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_N
             -EW)));
1560   1      #else
                      mode &= FA_READ;
                      res = auto_mount(&path, &dj.fs, 0);
              #endif
1564   1              if (res != FR_OK) LEAVE_FF(dj.fs, res);
1565   1              INITBUF(dj, sfn, lfn);
1566   1              res = follow_path(&dj, path);   /* Follow the file path */
1567   1      
1568   1      #if !_FS_READONLY
1569   1              /* Create or Open a file */
1570   1              if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
1571   2                      DWORD ps, cl;
1572   2      
1573   2                      if (res != FR_OK) {             /* No file, create new */
1574   3                              if (res == FR_NO_FILE)
1575   3                                      res = dir_register(&dj);
1576   3                              if (res != FR_OK) LEAVE_FF(dj.fs, res);
1577   3                              mode |= FA_CREATE_ALWAYS;
1578   3                              dir = dj.dir;
1579   3                      }
1580   2                      else {                                  /* Any object is already existing */
1581   3                              if (mode & FA_CREATE_NEW)                       /* Cannot create new */
1582   3                                      LEAVE_FF(dj.fs, FR_EXIST);
1583   3                              dir = dj.dir;
1584   3                              if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))        /* Cannot overwrite it (R/O or DIR) */
1585   3                                      LEAVE_FF(dj.fs, FR_DENIED);
1586   3                              if (mode & FA_CREATE_ALWAYS) {          /* Resize it to zero if needed */
1587   4                                      cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);    /* Get start cluster */
1588   4                                      ST_WORD(dir+DIR_FstClusHI, 0);  /* cluster = 0 */
1589   4                                      ST_WORD(dir+DIR_FstClusLO, 0);
1590   4                                      ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
1591   4                                      dj.fs->wflag = 1;
1592   4                                      ps = dj.fs->winsect;                    /* Remove the cluster chain */
1593   4                                      if (cl) {
1594   5                                              res = remove_chain(dj.fs, cl);
1595   5                                              if (res) LEAVE_FF(dj.fs, res);
1596   5                                              dj.fs->last_clust = cl - 1;     /* Reuse the cluster hole */
1597   5                                      }
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 27  

1598   4                                      res = move_window(dj.fs, ps);
1599   4                                      if (res != FR_OK) LEAVE_FF(dj.fs, res);
1600   4                              }
1601   3                      }
1602   2                      if (mode & FA_CREATE_ALWAYS) {
1603   3                              dir[DIR_Attr] = 0;                                      /* Reset attribute */
1604   3                              ps = get_fattime();
1605   3                              ST_DWORD(dir+DIR_CrtTime, ps);          /* Created time */
1606   3                              dj.fs->wflag = 1;
1607   3                              mode |= FA__WRITTEN;                            /* Set file changed flag */
1608   3                      }
1609   2              }
1610   1              /* Open an existing file */
1611   1              else {
1612   2      #endif /* !_FS_READONLY */
1613   2                      if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
1614   2                      dir = dj.dir;
1615   2                      if (!dir || (dir[DIR_Attr] & AM_DIR))   /* It is a directory */
1616   2                              LEAVE_FF(dj.fs, FR_NO_FILE);
1617   2      #if !_FS_READONLY
1618   2                      if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
1619   2                              LEAVE_FF(dj.fs, FR_DENIED);
1620   2              }
1621   1              fp->dir_sect = dj.fs->winsect;          /* Pointer to the directory entry */
1622   1              fp->dir_ptr = dj.dir;
1623   1      #endif
1624   1              fp->flag = mode;                                        /* File access mode */
1625   1              fp->org_clust =                                         /* File start cluster */
1626   1                      ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
1627   1              fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
1628   1              fp->fptr = 0; fp->csect = 255;          /* File pointer */
1629   1              fp->dsect = 0;
1630   1              fp->fs = dj.fs; fp->id = dj.fs->id;     /* Owner file system object of the file */
1631   1      
1632   1              LEAVE_FF(dj.fs, FR_OK);
1633   1      }
1634          
1635          
1636          
1637          
1638          /*-----------------------------------------------------------------------*/
1639          /* Read File                                                             */
1640          /*-----------------------------------------------------------------------*/
1641          
1642          FRESULT f_read (
1643                  FIL *fp,                /* Pointer to the file object */
1644                  void *buff,             /* Pointer to data buffer */
1645                  UINT btr,               /* Number of bytes to read */
1646                  UINT *br                /* Pointer to number of bytes read */
1647          )
1648          {
1649   1              FRESULT res;
1650   1              DWORD clst, sect, remain;
1651   1              UINT rcnt, cc;
1652   1              BYTE *rbuff = buff;
1653   1      
1654   1      
1655   1              *br = 0;
1656   1      
1657   1              res = validate(fp->fs, fp->id);                                 /* Check validity of the object */
1658   1              if (res != FR_OK) LEAVE_FF(fp->fs, res);
1659   1              if (fp->flag & FA__ERROR)                                               /* Check abort flag */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 28  

1660   1                      LEAVE_FF(fp->fs, FR_INT_ERR);
1661   1              if (!(fp->flag & FA_READ))                                              /* Check access mode */
1662   1                      LEAVE_FF(fp->fs, FR_DENIED);
1663   1              remain = fp->fsize - fp->fptr;
1664   1              if (btr > remain) btr = (UINT)remain;                   /* Truncate btr by remaining bytes */
1665   1      
1666   1              for ( ;  btr;                                                                   /* Repeat until all data transferred */
1667   1                      rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
1668   2                      if ((fp->fptr % SS(fp->fs)) == 0) {                     /* On the sector boundary? */
1669   3                              if (fp->csect >= fp->fs->csize) {               /* On the cluster boundary? */
1670   4                                      clst = (fp->fptr == 0) ?                        /* On the top of the file? */
1671   4                                              fp->org_clust : get_cluster(fp->fs, fp->curr_clust);
1672   4                                      if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
1673   4                                      if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
1674   4                                      fp->curr_clust = clst;                          /* Update current cluster */
1675   4                                      fp->csect = 0;                                          /* Reset sector offset in the cluster */
1676   4                              }
1677   3                              sect = clust2sect(fp->fs, fp->curr_clust);      /* Get current sector */
1678   3                              if (!sect) ABORT(fp->fs, FR_INT_ERR);
1679   3                              sect += fp->csect;
1680   3                              cc = btr / SS(fp->fs);                                  /* When remaining bytes >= sector size, */
1681   3                              if (cc) {                                                               /* Read maximum contiguous sectors directly */
1682   4                                      if (fp->csect + cc > fp->fs->csize)     /* Clip at cluster boundary */
1683   4                                              cc = fp->fs->csize - fp->csect;
1684   4                                      if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
1685   4                                              ABORT(fp->fs, FR_DISK_ERR);
1686   4                                      fp->csect += (BYTE)cc;                          /* Next sector address in the cluster */
1687   4                                      rcnt = SS(fp->fs) * cc;                         /* Number of bytes transferred */
1688   4                                      continue;
1689   4                              }
1690   3      #if !_FS_TINY
1691   3      #if !_FS_READONLY
1692   3                              if (fp->flag & FA__DIRTY) {                     /* Write sector I/O buffer if needed */
1693   4                                      if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
1694   4                                              ABORT(fp->fs, FR_DISK_ERR);
1695   4                                      fp->flag &= (BYTE)~FA__DIRTY;
1696   4                              }
1697   3      #endif
1698   3                              if (fp->dsect != sect) {                        /* Fill sector buffer with file data */
1699   4                                      if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
1700   4                                              ABORT(fp->fs, FR_DISK_ERR);
1701   4                              }
1702   3      #endif
1703   3                              fp->dsect = sect;
1704   3                              fp->csect++;                                                    /* Next sector address in the cluster */
1705   3                      }
1706   2                      rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));    /* Get partial sector data from sector buffer */
1707   2                      if (rcnt > btr) rcnt = btr;
1708   2      #if _FS_TINY
                              if (move_window(fp->fs, fp->dsect))                     /* Move sector window */
                                      ABORT(fp->fs, FR_DISK_ERR);
                              mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);      /* Pick partial sector */
              #else
1713   2                      mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
1714   2      #endif
1715   2              }
1716   1      
1717   1      
1718   1              LEAVE_FF(fp->fs, FR_OK);
1719   1      }
1720          
1721          
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 29  

1722          
1723          
1724          #if !_FS_READONLY
1725          /*-----------------------------------------------------------------------*/
1726          /* Write File                                                            */
1727          /*-----------------------------------------------------------------------*/
1728          
1729          FRESULT f_write (
1730                  FIL *fp,                        /* Pointer to the file object */
1731                  const void *buff,       /* Pointer to the data to be written */
1732                  UINT btw,                       /* Number of bytes to write */
1733                  UINT *bw                        /* Pointer to number of bytes written */
1734          )
1735          {
1736   1              FRESULT res;
1737   1              DWORD clst, sect;
1738   1              UINT wcnt, cc;
1739   1              const BYTE *wbuff = buff;
1740   1      
1741   1      
1742   1              *bw = 0;
1743   1      
1744   1              res = validate(fp->fs, fp->id);                                 /* Check validity of the object */
1745   1              if (res != FR_OK) LEAVE_FF(fp->fs, res);
1746   1              if (fp->flag & FA__ERROR)                                               /* Check abort flag */
1747   1                      LEAVE_FF(fp->fs, FR_INT_ERR);
1748   1              if (!(fp->flag & FA_WRITE))                                             /* Check access mode */
1749   1                      LEAVE_FF(fp->fs, FR_DENIED);
1750   1              if (fp->fsize + btw < fp->fsize) btw = 0;               /* File size cannot reach 4GB */
1751   1      
1752   1              for ( ;  btw;                                                                   /* Repeat until all data transferred */
1753   1                      wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
1754   2                      if ((fp->fptr % SS(fp->fs)) == 0) {                     /* On the sector boundary? */
1755   3                              if (fp->csect >= fp->fs->csize) {               /* On the cluster boundary? */
1756   4                                      if (fp->fptr == 0) {                            /* On the top of the file? */
1757   5                                              clst = fp->org_clust;                   /* Follow from the origin */
1758   5                                              if (clst == 0)                                  /* When there is no cluster chain, */
1759   5                                                      fp->org_clust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
1760   5                                      } else {                                                        /* Middle or end of the file */
1761   5                                              clst = create_chain(fp->fs, fp->curr_clust);                    /* Follow or streach cluster chain */
1762   5                                      }
1763   4                                      if (clst == 0) break;                           /* Could not allocate a new cluster (disk full) */
1764   4                                      if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
1765   4                                      if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
1766   4                                      fp->curr_clust = clst;                          /* Update current cluster */
1767   4                                      fp->csect = 0;                                          /* Reset sector address in the cluster */
1768   4                              }
1769   3      #if _FS_TINY
                                      if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))     /* Write back data buffer prior to followin
             -g direct transfer */
                                              ABORT(fp->fs, FR_DISK_ERR);
              #else
1773   3                              if (fp->flag & FA__DIRTY) {             /* Write back data buffer prior to following direct transfer */
1774   4                                      if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
1775   4                                              ABORT(fp->fs, FR_DISK_ERR);
1776   4                                      fp->flag &= (BYTE)~FA__DIRTY;
1777   4                              }
1778   3      #endif
1779   3                              sect = clust2sect(fp->fs, fp->curr_clust);      /* Get current sector */
1780   3                              if (!sect) ABORT(fp->fs, FR_INT_ERR);
1781   3                              sect += fp->csect;
1782   3                              cc = btw / SS(fp->fs);                                  /* When remaining bytes >= sector size, */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 30  

1783   3                              if (cc) {                                                               /* Write maximum contiguous sectors directly */
1784   4                                      if (fp->csect + cc > fp->fs->csize)     /* Clip at cluster boundary */
1785   4                                              cc = fp->fs->csize - fp->csect;
1786   4                                      if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
1787   4                                              ABORT(fp->fs, FR_DISK_ERR);
1788   4                                      fp->csect += (BYTE)cc;                          /* Next sector address in the cluster */
1789   4                                      wcnt = SS(fp->fs) * cc;                         /* Number of bytes transferred */
1790   4                                      continue;
1791   4                              }
1792   3      #if _FS_TINY
                                      if (fp->fptr >= fp->fsize) {                    /* Avoid silly buffer filling at growing edge */
                                              if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
                                              fp->fs->winsect = sect;
                                      }
              #else
1798   3                              if (fp->dsect != sect) {                                /* Fill sector buffer with file data */
1799   4                                      if (fp->fptr < fp->fsize &&
1800   4                                              disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
1801   4                                                      ABORT(fp->fs, FR_DISK_ERR);
1802   4                              }
1803   3      #endif
1804   3                              fp->dsect = sect;
1805   3                              fp->csect++;                                                    /* Next sector address in the cluster */
1806   3                      }
1807   2                      wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));    /* Put partial sector into file I/O buffer */
1808   2                      if (wcnt > btw) wcnt = btw;
1809   2      #if _FS_TINY
                              if (move_window(fp->fs, fp->dsect))                     /* Move sector window */
                                      ABORT(fp->fs, FR_DISK_ERR);
                              mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);      /* Fit partial sector */
                              fp->fs->wflag = 1;
              #else
1815   2                      mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
1816   2                      fp->flag |= FA__DIRTY;
1817   2      #endif
1818   2              }
1819   1      
1820   1              if (fp->fptr > fp->fsize) fp->fsize = fp->fptr; /* Update file size if needed */
1821   1              fp->flag |= FA__WRITTEN;                                                /* Set file changed flag */
1822   1      
1823   1              LEAVE_FF(fp->fs, FR_OK);
1824   1      }
1825          
1826          
1827          
1828          
1829          /*-----------------------------------------------------------------------*/
1830          /* Synchronize the File Object                                           */
1831          /*-----------------------------------------------------------------------*/
1832          
1833          FRESULT f_sync (
1834                  FIL *fp         /* Pointer to the file object */
1835          )
1836          {
1837   1              FRESULT res;
1838   1              DWORD tim;
1839   1              BYTE *dir;
1840   1      
1841   1      
1842   1              res = validate(fp->fs, fp->id);         /* Check validity of the object */
1843   1              if (res == FR_OK) {
1844   2                      if (fp->flag & FA__WRITTEN) {   /* Has the file been written? */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 31  

1845   3      #if !_FS_TINY   /* Write-back dirty buffer */
1846   3                              if (fp->flag & FA__DIRTY) {
1847   4                                      if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
1848   4                                              LEAVE_FF(fp->fs, FR_DISK_ERR);
1849   4                                      fp->flag &= (BYTE)~FA__DIRTY;
1850   4                              }
1851   3      #endif
1852   3                              /* Update the directory entry */
1853   3                              res = move_window(fp->fs, fp->dir_sect);
1854   3                              if (res == FR_OK) {
1855   4                                      dir = fp->dir_ptr;
1856   4                                      dir[DIR_Attr] |= AM_ARC;                                        /* Set archive bit */
1857   4                                      ST_DWORD(dir+DIR_FileSize, fp->fsize);          /* Update file size */
1858   4                                      ST_WORD(dir+DIR_FstClusLO, fp->org_clust);      /* Update start cluster */
1859   4                                      ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
1860   4                                      tim = get_fattime();                                    /* Updated time */
1861   4                                      ST_DWORD(dir+DIR_WrtTime, tim);
1862   4                                      fp->flag &= (BYTE)~FA__WRITTEN;
1863   4                                      fp->fs->wflag = 1;
1864   4                                      res = sync(fp->fs);
1865   4                              }
1866   3                      }
1867   2              }
1868   1      
1869   1              LEAVE_FF(fp->fs, res);
1870   1      }
1871          
1872          #endif /* !_FS_READONLY */
1873          
1874          
1875          
1876          
1877          /*-----------------------------------------------------------------------*/
1878          /* Close File                                                            */
1879          /*-----------------------------------------------------------------------*/
1880          
1881          FRESULT f_close (
1882                  FIL *fp         /* Pointer to the file object to be closed */
1883          )
1884          {
1885   1              FRESULT res;
1886   1      
1887   1      
1888   1      #if _FS_READONLY
                      res = validate(fp->fs, fp->id);
                      if (res == FR_OK) fp->fs = NULL;
                      LEAVE_FF(fp->fs, res);
              #else
1893   1              res = f_sync(fp);
1894   1              if (res == FR_OK) fp->fs = NULL;
1895   1              return res;
1896   1      #endif
1897   1      }
1898          
1899          
1900          
1901          
1902          #if _FS_MINIMIZE <= 2
1903          /*-----------------------------------------------------------------------*/
1904          /* Seek File R/W Pointer                                                 */
1905          /*-----------------------------------------------------------------------*/
1906          
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 32  

1907          FRESULT f_lseek (
1908                  FIL *fp,                /* Pointer to the file object */
1909                  DWORD ofs               /* File pointer from top of file */
1910          )
1911          {
1912   1              FRESULT res;
1913   1              DWORD clst, bcs, nsect, ifptr;
1914   1      
1915   1      
1916   1              res = validate(fp->fs, fp->id);         /* Check validity of the object */
1917   1              if (res != FR_OK) LEAVE_FF(fp->fs, res);
1918   1              if (fp->flag & FA__ERROR)                       /* Check abort flag */
1919   1                      LEAVE_FF(fp->fs, FR_INT_ERR);
1920   1              if (ofs > fp->fsize                                     /* In read-only mode, clip offset with the file size */
1921   1      #if !_FS_READONLY
1922   1                       && !(fp->flag & FA_WRITE)
1923   1      #endif
1924   1                      ) ofs = fp->fsize;
1925   1      
1926   1              ifptr = fp->fptr;
1927   1              fp->fptr = 0; fp->csect = 255;
1928   1              nsect = 0;
1929   1              if (ofs > 0) {
1930   2                      bcs = (DWORD)fp->fs->csize * SS(fp->fs);        /* Cluster size (byte) */
1931   2                      if (ifptr > 0 &&
1932   2                              (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
1933   3                              fp->fptr = (ifptr - 1) & ~(bcs - 1);    /* start from the current cluster */
1934   3                              ofs -= fp->fptr;
1935   3                              clst = fp->curr_clust;
1936   3                      } else {                                                                        /* When seek to back cluster, */
1937   3                              clst = fp->org_clust;                                   /* start from the first cluster */
1938   3      #if !_FS_READONLY
1939   3                              if (clst == 0) {                                                /* If no cluster chain, create a new chain */
1940   4                                      clst = create_chain(fp->fs, 0);
1941   4                                      if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
1942   4                                      if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
1943   4                                      fp->org_clust = clst;
1944   4                              }
1945   3      #endif
1946   3                              fp->curr_clust = clst;
1947   3                      }
1948   2                      if (clst != 0) {
1949   3                              while (ofs > bcs) {                                             /* Cluster following loop */
1950   4      #if !_FS_READONLY
1951   4                                      if (fp->flag & FA_WRITE) {                      /* Check if in write mode or not */
1952   5                                              clst = create_chain(fp->fs, clst);      /* Force streached if in write mode */
1953   5                                              if (clst == 0) {                                /* When disk gets full, clip file size */
1954   6                                                      ofs = bcs; break;
1955   6                                              }
1956   5                                      } else
1957   4      #endif
1958   4                                              clst = get_cluster(fp->fs, clst);       /* Follow cluster chain if not in write mode */
1959   4                                      if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
1960   4                                      if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
1961   4                                      fp->curr_clust = clst;
1962   4                                      fp->fptr += bcs;
1963   4                                      ofs -= bcs;
1964   4                              }
1965   3                              fp->fptr += ofs;
1966   3                              fp->csect = (BYTE)(ofs / SS(fp->fs));   /* Sector offset in the cluster */
1967   3                              if (ofs % SS(fp->fs)) {
1968   4                                      nsect = clust2sect(fp->fs, clst);       /* Current sector */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 33  

1969   4                                      if (!nsect) ABORT(fp->fs, FR_INT_ERR);
1970   4                                      nsect += fp->csect;
1971   4                                      fp->csect++;
1972   4                              }
1973   3                      }
1974   2              }
1975   1              if (nsect && nsect != fp->dsect && fp->fptr % SS(fp->fs)) {
1976   2      #if !_FS_TINY
1977   2      #if !_FS_READONLY
1978   2                      if (fp->flag & FA__DIRTY) {                     /* Write-back dirty buffer if needed */
1979   3                              if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
1980   3                                      ABORT(fp->fs, FR_DISK_ERR);
1981   3                              fp->flag &= (BYTE)~FA__DIRTY;
1982   3                      }
1983   2      #endif
1984   2                      if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
1985   2                              ABORT(fp->fs, FR_DISK_ERR);
1986   2      #endif
1987   2                      fp->dsect = nsect;
1988   2              }
1989   1      #if !_FS_READONLY
1990   1              if (fp->fptr > fp->fsize) {                     /* Set changed flag if the file size is extended */
1991   2                      fp->fsize = fp->fptr;
1992   2                      fp->flag |= FA__WRITTEN;
1993   2              }
1994   1      #endif
1995   1      
1996   1              LEAVE_FF(fp->fs, res);
1997   1      }
1998          
1999          
2000          
2001          
2002          #if _FS_MINIMIZE <= 1
2003          /*-----------------------------------------------------------------------*/
2004          /* Create a Directroy Object                                             */
2005          /*-----------------------------------------------------------------------*/
2006          
2007          FRESULT f_opendir (
2008                  DIR *dj,                        /* Pointer to directory object to create */
2009                  const char *path        /* Pointer to the directory path */
2010          )
2011          {
2012   1              FRESULT res;
2013   1              NAMEBUF(sfn, lfn);
2014   1              BYTE *dir;
2015   1      
2016   1      
2017   1              res = auto_mount(&path, &dj->fs, 0);
2018   1              if (res == FR_OK) {
2019   2                      INITBUF((*dj), sfn, lfn);
2020   2                      res = follow_path(dj, path);                    /* Follow the path to the directory */
2021   2                      if (res == FR_OK) {                                             /* Follow completed */
2022   3                              dir = dj->dir;
2023   3                              if (dir) {                                                      /* It is not the root dir */
2024   4                                      if (dir[DIR_Attr] & AM_DIR) {   /* The object is a directory */
2025   5                                              dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
2026   5                                      } else {                                                /* The object is not a directory */
2027   5                                              res = FR_NO_PATH;
2028   5                                      }
2029   4                              } else {                                                        /* It is the root dir */
2030   4                                      dj->sclust = (dj->fs->fs_type == FS_FAT32) ? dj->fs->dirbase : 0;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 34  

2031   4                              }
2032   3                              if (res == FR_OK) res = dir_seek(dj, 0);
2033   3                              dj->id = dj->fs->id;
2034   3                      } else {
2035   3                              if (res == FR_NO_FILE) res = FR_NO_PATH;
2036   3                      }
2037   2              }
2038   1      
2039   1              LEAVE_FF(dj->fs, res);
2040   1      }
2041          
2042          
2043          
2044          
2045          /*-----------------------------------------------------------------------*/
2046          /* Read Directory Entry in Sequense                                      */
2047          /*-----------------------------------------------------------------------*/
2048          
2049          FRESULT f_readdir (
2050                  DIR *dj,                        /* Pointer to the open directory object */
2051                  FILINFO *fno            /* Pointer to file information to return */
2052          )
2053          {
2054   1              FRESULT res;
2055   1              NAMEBUF(sfn, lfn);
2056   1      
2057   1      
2058   1              res = validate(dj->fs, dj->id);                 /* Check validity of the object */
2059   1              if (res == FR_OK) {
2060   2                      INITBUF((*dj), sfn, lfn);
2061   2                      if (!fno) {
2062   3                              res = dir_seek(dj, 0);
2063   3                      } else {
2064   3                              res = dir_read(dj);
2065   3                              if (res == FR_NO_FILE) {
2066   4                                      dj->sect = 0;
2067   4                                      res = FR_OK;
2068   4                              }
2069   3                              if (res == FR_OK) {                             /* A valid entry is found */
2070   4                                      get_fileinfo(dj, fno);          /* Get the object information */
2071   4                                      res = dir_next(dj, FALSE);      /* Increment index for next */
2072   4                                      if (res == FR_NO_FILE) {
2073   5                                              dj->sect = 0;
2074   5                                              res = FR_OK;
2075   5                                      }
2076   4                              }
2077   3                      }
2078   2              }
2079   1      
2080   1              LEAVE_FF(dj->fs, res);
2081   1      }
2082          
2083          
2084          
2085          #if _FS_MINIMIZE == 0
2086          /*-----------------------------------------------------------------------*/
2087          /* Get File Status                                                       */
2088          /*-----------------------------------------------------------------------*/
2089          
2090          FRESULT f_stat (
2091                  const char *path,       /* Pointer to the file path */
2092                  FILINFO *fno            /* Pointer to file information to return */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 35  

2093          )
2094          {
2095   1              FRESULT res;
2096   1              DIR dj;
2097   1              NAMEBUF(sfn, lfn);
2098   1      
2099   1      
2100   1              res = auto_mount(&path, &dj.fs, 0);
2101   1              if (res == FR_OK) {
2102   2                      INITBUF(dj, sfn, lfn);
2103   2                      res = follow_path(&dj, path);   /* Follow the file path */
2104   2                      if (res == FR_OK) {                             /* Follwo completed */
2105   3                              if (dj.dir)     /* Found an object */
2106   3                                      get_fileinfo(&dj, fno);
2107   3                              else            /* It is root dir */
2108   3                                      res = FR_INVALID_NAME;
2109   3                      }
2110   2              }
2111   1      
2112   1              LEAVE_FF(dj.fs, res);
2113   1      }
2114          
2115          
2116          
2117          #if !_FS_READONLY
2118          /*-----------------------------------------------------------------------*/
2119          /* Truncate File                                                         */
2120          /*-----------------------------------------------------------------------*/
2121          
2122          FRESULT f_truncate (
2123                  FIL *fp         /* Pointer to the file object */
2124          )
2125          {
2126   1              FRESULT res;
2127   1              DWORD ncl;
2128   1      
2129   1      
2130   1              res = validate(fp->fs, fp->id);         /* Check validity of the object */
2131   1              if (res != FR_OK) LEAVE_FF(fp->fs, res);
2132   1              if (fp->flag & FA__ERROR)                       /* Check abort flag */
2133   1                      LEAVE_FF(fp->fs, FR_INT_ERR);
2134   1              if (!(fp->flag & FA_WRITE))                     /* Check access mode */
2135   1                      LEAVE_FF(fp->fs, FR_DENIED);
2136   1      
2137   1              if (fp->fsize > fp->fptr) {
2138   2                      fp->fsize = fp->fptr;   /* Set file size to current R/W point */
2139   2                      fp->flag |= FA__WRITTEN;
2140   2                      if (fp->fptr == 0) {    /* When set file size to zero, remove entire cluster chain */
2141   3                              res = remove_chain(fp->fs, fp->org_clust);
2142   3                              fp->org_clust = 0;
2143   3                      } else {                                /* When truncate a part of the file, remove remaining clusters */
2144   3                              ncl = get_cluster(fp->fs, fp->curr_clust);
2145   3                              res = FR_OK;
2146   3                              if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
2147   3                              if (ncl == 1) res = FR_INT_ERR;
2148   3                              if (res == FR_OK && ncl < fp->fs->max_clust) {
2149   4                                      res = put_cluster(fp->fs, fp->curr_clust, 0x0FFFFFFF);
2150   4                                      if (res == FR_OK) res = remove_chain(fp->fs, ncl);
2151   4                              }
2152   3                      }
2153   2              }
2154   1              if (res != FR_OK) fp->flag |= FA__ERROR;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 36  

2155   1      
2156   1              LEAVE_FF(fp->fs, res);
2157   1      }
2158          
2159          
2160          
2161          
2162          /*-----------------------------------------------------------------------*/
2163          /* Get Number of Free Clusters                                           */
2164          /*-----------------------------------------------------------------------*/
2165          
2166          FRESULT f_getfree (
2167                  const char *path,       /* Pointer to the logical drive number (root dir) */
2168                  DWORD *nclst,           /* Pointer to the variable to return number of free clusters */
2169                  FATFS **fatfs           /* Pointer to pointer to corresponding file system object to return */
2170          )
2171          {
2172   1              FRESULT res;
2173   1              DWORD n, clst, sect;
2174   1              BYTE fat, f, *p;
2175   1      
2176   1      
2177   1              /* Get drive number */
2178   1              res = auto_mount(&path, fatfs, 0);
2179   1              if (res != FR_OK) LEAVE_FF(*fatfs, res);
2180   1      
2181   1              /* If number of free cluster is valid, return it without cluster scan. */
2182   1              if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
2183   2                      *nclst = (*fatfs)->free_clust;
2184   2                      LEAVE_FF(*fatfs, FR_OK);
2185   2              }
2186   1      
2187   1              /* Get number of free clusters */
2188   1              fat = (*fatfs)->fs_type;
2189   1              n = 0;
2190   1              if (fat == FS_FAT12) {
2191   2                      clst = 2;
2192   2                      do {
2193   3                              if ((WORD)get_cluster(*fatfs, clst) == 0) n++;
2194   3                      } while (++clst < (*fatfs)->max_clust);
2195   2              } else {
2196   2                      clst = (*fatfs)->max_clust;
2197   2                      sect = (*fatfs)->fatbase;
2198   2                      f = 0; p = 0;
2199   2                      do {
2200   3                              if (!f) {
2201   4                                      res = move_window(*fatfs, sect++);
2202   4                                      if (res != FR_OK)
2203   4                                              LEAVE_FF(*fatfs, res);
2204   4                                      p = (*fatfs)->win;
2205   4                              }
2206   3                              if (fat == FS_FAT16) {
2207   4                                      if (LD_WORD(p) == 0) n++;
2208   4                                      p += 2; f += 1;
2209   4                              } else {
2210   4                                      if (LD_DWORD(p) == 0) n++;
2211   4                                      p += 4; f += 2;
2212   4                              }
2213   3                      } while (--clst);
2214   2              }
2215   1              (*fatfs)->free_clust = n;
2216   1              if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 37  

2217   1              *nclst = n;
2218   1      
2219   1              LEAVE_FF(*fatfs, FR_OK);
2220   1      }
2221          
2222          
2223          
2224          
2225          /*-----------------------------------------------------------------------*/
2226          /* Delete a File or Directory                                            */
2227          /*-----------------------------------------------------------------------*/
2228          
2229          FRESULT f_unlink (
2230                  const char *path                /* Pointer to the file or directory path */
2231          )
2232          {
2233   1              FRESULT res;
2234   1              DIR dj, sdj;
2235   1              NAMEBUF(sfn, lfn);
2236   1              BYTE *dir;
2237   1              DWORD dclst;
2238   1      
2239   1      
2240   1              res = auto_mount(&path, &dj.fs, 1);
2241   1              if (res != FR_OK) LEAVE_FF(dj.fs, res);
2242   1      
2243   1              INITBUF(dj, sfn, lfn);
2244   1              res = follow_path(&dj, path);                   /* Follow the file path */
2245   1              if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
2246   1      
2247   1              dir = dj.dir;
2248   1              if (!dir)                                                               /* Is it the root directory? */
2249   1                      LEAVE_FF(dj.fs, FR_INVALID_NAME);
2250   1              if (dir[DIR_Attr] & AM_RDO)                             /* Is it a R/O object? */
2251   1                      LEAVE_FF(dj.fs, FR_DENIED);
2252   1              dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
2253   1      
2254   1              if (dir[DIR_Attr] & AM_DIR) {                   /* It is a sub-directory */
2255   2                      if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
2256   2                      mem_cpy(&sdj, &dj, sizeof(DIR));                /* Check if the sub-dir is empty or not */
2257   2                      sdj.sclust = dclst;
2258   2                      res = dir_seek(&sdj, 0);
2259   2                      if (res != FR_OK) LEAVE_FF(dj.fs, res);
2260   2                      res = dir_read(&sdj);
2261   2                      if (res == FR_OK) res = FR_DENIED;      /* Not empty sub-dir */
2262   2                      if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
2263   2              }
2264   1      
2265   1              res = dir_remove(&dj);                                  /* Remove directory entry */
2266   1              if (res == FR_OK) {
2267   2                      if (dclst)
2268   2                              res = remove_chain(dj.fs, dclst);       /* Remove the cluster chain */
2269   2                      if (res == FR_OK) res = sync(dj.fs);
2270   2              }
2271   1      
2272   1              LEAVE_FF(dj.fs, FR_OK);
2273   1      }
2274          
2275          
2276          
2277          
2278          /*-----------------------------------------------------------------------*/
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 38  

2279          /* Create a Directory                                                    */
2280          /*-----------------------------------------------------------------------*/
2281          
2282          FRESULT f_mkdir (
2283                  const char *path                /* Pointer to the directory path */
2284          )
2285          {
2286   1              FRESULT res;
2287   1              DIR dj;
2288   1              NAMEBUF(sfn, lfn);
2289   1              BYTE *dir, n;
2290   1              DWORD dsect, dclst, pclst, tim;
2291   1      
2292   1      
2293   1              res = auto_mount(&path, &dj.fs, 1);
2294   1              if (res != FR_OK) LEAVE_FF(dj.fs, res);
2295   1      
2296   1              INITBUF(dj, sfn, lfn);
2297   1              res = follow_path(&dj, path);                   /* Follow the file path */
2298   1              if (res == FR_OK) res = FR_EXIST;               /* Any file or directory is already existing */
2299   1              if (res != FR_NO_FILE)                                  /* Any error occured */
2300   1                      LEAVE_FF(dj.fs, res);
2301   1      
2302   1              dclst = create_chain(dj.fs, 0);                 /* Allocate a new cluster for new directory table */
2303   1              res = FR_OK;
2304   1              if (dclst == 0) res = FR_DENIED;
2305   1              if (dclst == 1) res = FR_INT_ERR;
2306   1              if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
2307   1              if (res == FR_OK)
2308   1                      res = move_window(dj.fs, 0);
2309   1              if (res != FR_OK) LEAVE_FF(dj.fs, res);
2310   1              dsect = clust2sect(dj.fs, dclst);
2311   1      
2312   1              dir = dj.fs->win;                                               /* Initialize the new directory table */
2313   1              mem_set(dir, 0, SS(dj.fs));
2314   1              mem_set(dir+DIR_Name, ' ', 8+3);                /* Create "." entry */
2315   1              dir[DIR_Name] = '.';
2316   1              dir[DIR_Attr] = AM_DIR;
2317   1              tim = get_fattime();
2318   1              ST_DWORD(dir+DIR_WrtTime, tim);
2319   1              ST_WORD(dir+DIR_FstClusLO, dclst);
2320   1              ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
2321   1              mem_cpy(dir+32, dir, 32);                       /* Create ".." entry */
2322   1              dir[33] = '.';
2323   1              pclst = dj.sclust;
2324   1              if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
2325   1                      pclst = 0;
2326   1              ST_WORD(dir+32+DIR_FstClusLO, pclst);
2327   1              ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
2328   1              for (n = 0; n < dj.fs->csize; n++) {    /* Write dot entries and clear left sectors */
2329   2                      dj.fs->winsect = dsect++;
2330   2                      dj.fs->wflag = 1;
2331   2                      res = move_window(dj.fs, 0);
2332   2                      if (res) LEAVE_FF(dj.fs, res);
2333   2                      mem_set(dir, 0, SS(dj.fs));
2334   2              }
2335   1      
2336   1              res = dir_register(&dj);
2337   1              if (res != FR_OK) {
2338   2                      remove_chain(dj.fs, dclst);
2339   2              } else {
2340   2                      dir = dj.dir;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 39  

2341   2                      dir[DIR_Attr] = AM_DIR;                                 /* Attribute */
2342   2                      ST_DWORD(dir+DIR_WrtTime, tim);                 /* Crated time */
2343   2                      ST_WORD(dir+DIR_FstClusLO, dclst);              /* Table start cluster */
2344   2                      ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
2345   2                      dj.fs->wflag = 1;
2346   2                      res = sync(dj.fs);
2347   2              }
2348   1      
2349   1              LEAVE_FF(dj.fs, res);
2350   1      }
2351          
2352          
2353          
2354          
2355          /*-----------------------------------------------------------------------*/
2356          /* Change File Attribute                                                 */
2357          /*-----------------------------------------------------------------------*/
2358          
2359          FRESULT f_chmod (
2360                  const char *path,       /* Pointer to the file path */
2361                  BYTE value,                     /* Attribute bits */
2362                  BYTE mask                       /* Attribute mask to change */
2363          )
2364          {
2365   1              FRESULT res;
2366   1              DIR dj;
2367   1              NAMEBUF(sfn, lfn);
2368   1              BYTE *dir;
2369   1      
2370   1      
2371   1              res = auto_mount(&path, &dj.fs, 1);
2372   1              if (res == FR_OK) {
2373   2                      INITBUF(dj, sfn, lfn);
2374   2                      res = follow_path(&dj, path);           /* Follow the file path */
2375   2                      if (res == FR_OK) {
2376   3                              dir = dj.dir;
2377   3                              if (!dir) {                                             /* Is it a root directory? */
2378   4                                      res = FR_INVALID_NAME;
2379   4                              } else {                                                /* File or sub directory */
2380   4                                      mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;    /* Valid attribute mask */
2381   4                                      dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask); /* Apply attribute change */
2382   4                                      dj.fs->wflag = 1;
2383   4                                      res = sync(dj.fs);
2384   4                              }
2385   3                      }
2386   2              }
2387   1      
2388   1              LEAVE_FF(dj.fs, res);
2389   1      }
2390          
2391          
2392          
2393          
2394          /*-----------------------------------------------------------------------*/
2395          /* Change Timestamp                                                      */
2396          /*-----------------------------------------------------------------------*/
2397          
2398          FRESULT f_utime (
2399                  const char *path,       /* Pointer to the file/directory name */
2400                  const FILINFO *fno      /* Pointer to the timestamp to be set */
2401          )
2402          {
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 40  

2403   1              FRESULT res;
2404   1              DIR dj;
2405   1              NAMEBUF(sfn, lfn);
2406   1              BYTE *dir;
2407   1      
2408   1      
2409   1              res = auto_mount(&path, &dj.fs, 1);
2410   1              if (res == FR_OK) {
2411   2                      INITBUF(dj, sfn, lfn);
2412   2                      res = follow_path(&dj, path);   /* Follow the file path */
2413   2                      if (res == FR_OK) {
2414   3                              dir = dj.dir;
2415   3                              if (!dir) {                             /* Root directory */
2416   4                                      res = FR_INVALID_NAME;
2417   4                              } else {                                /* File or sub-directory */
2418   4                                      ST_WORD(dir+DIR_WrtTime, fno->ftime);
2419   4                                      ST_WORD(dir+DIR_WrtDate, fno->fdate);
2420   4                                      dj.fs->wflag = 1;
2421   4                                      res = sync(dj.fs);
2422   4                              }
2423   3                      }
2424   2              }
2425   1      
2426   1              LEAVE_FF(dj.fs, res);
2427   1      }
2428          
2429          
2430          
2431          
2432          /*-----------------------------------------------------------------------*/
2433          /* Rename File/Directory                                                 */
2434          /*-----------------------------------------------------------------------*/
2435          
2436          FRESULT f_rename (
2437                  const char *path_old,   /* Pointer to the old name */
2438                  const char *path_new    /* Pointer to the new name */
2439          )
2440          {
2441   1              FRESULT res;
2442   1              DIR dj_old, dj_new;
2443   1              NAMEBUF(sfn, lfn);
2444   1              BYTE buf[21], *dir;
2445   1              DWORD dw;
2446   1      
2447   1      
2448   1              INITBUF(dj_old, sfn, lfn);
2449   1              res = auto_mount(&path_old, &dj_old.fs, 1);
2450   1              if (res == FR_OK) {
2451   2                      dj_new.fs = dj_old.fs;
2452   2                      res = follow_path(&dj_old, path_old);   /* Check old object */
2453   2              }
2454   1              if (res != FR_OK) LEAVE_FF(dj_old.fs, res);     /* The old object is not found */
2455   1      
2456   1              if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);       /* Is root dir? */
2457   1              mem_cpy(buf, dj_old.dir+DIR_Attr, 21);          /* Save the object information */
2458   1      
2459   1              mem_cpy(&dj_new, &dj_old, sizeof(DIR));
2460   1              res = follow_path(&dj_new, path_new);           /* Check new object */
2461   1              if (res == FR_OK) res = FR_EXIST;                       /* The new object name is already existing */
2462   1              if (res == FR_NO_FILE) {                                        /* Is it a valid path and no name collision? */
2463   2                      res = dir_register(&dj_new);                    /* Register the new object */
2464   2                      if (res == FR_OK) {
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 41  

2465   3                              dir = dj_new.dir;                                       /* Copy object information into new entry */
2466   3                              mem_cpy(dir+13, buf+2, 19);
2467   3                              dir[DIR_Attr] = buf[0];
2468   3                              dj_old.fs->wflag = 1;
2469   3                              if (dir[DIR_Attr] & AM_DIR) {           /* Update .. entry in the directory if needed */
2470   4                                      dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
2471   4                                      if (!dw) {
2472   5                                              res = FR_INT_ERR;
2473   5                                      } else {
2474   5                                              res = move_window(dj_new.fs, dw);
2475   5                                              dir = dj_new.fs->win+32;
2476   5                                              if (res == FR_OK && dir[1] == '.') {
2477   6                                                      dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
2478   6                                                      ST_WORD(dir+DIR_FstClusLO, dw);
2479   6                                                      ST_WORD(dir+DIR_FstClusHI, dw >> 16);
2480   6                                                      dj_new.fs->wflag = 1;
2481   6                                              }
2482   5                                      }
2483   4                              }
2484   3                              if (res == FR_OK) {
2485   4                                      res = dir_remove(&dj_old);                      /* Remove old entry */
2486   4                                      if (res == FR_OK)
2487   4                                              res = sync(dj_old.fs);
2488   4                              }
2489   3                      }
2490   2              }
2491   1      
2492   1              LEAVE_FF(dj_old.fs, res);
2493   1      }
2494          
2495          #endif /* !_FS_READONLY */
2496          #endif /* _FS_MINIMIZE == 0 */
2497          #endif /* _FS_MINIMIZE <= 1 */
2498          #endif /* _FS_MINIMIZE <= 2 */
2499          
2500          
2501          
2502          /*-----------------------------------------------------------------------*/
2503          /* Forward data to the stream directly (Available on only _FS_TINY cfg)  */
2504          /*-----------------------------------------------------------------------*/
2505          #if _USE_FORWARD && _FS_TINY
              
              FRESULT f_forward (
                      FIL *fp,                                                /* Pointer to the file object */
                      UINT (*func)(const BYTE*,UINT), /* Pointer to the streaming function */
                      UINT btr,                                               /* Number of bytes to forward */
                      UINT *bf                                                /* Pointer to number of bytes forwarded */
              )
              {
                      FRESULT res;
                      DWORD remain, clst, sect;
                      UINT rcnt;
              
              
                      *bf = 0;
              
                      res = validate(fp->fs, fp->id);                                 /* Check validity of the object */
                      if (res != FR_OK) LEAVE_FF(fp->fs, res);
                      if (fp->flag & FA__ERROR)                                               /* Check error flag */
                              LEAVE_FF(fp->fs, FR_INT_ERR);
                      if (!(fp->flag & FA_READ))                                              /* Check access mode */
                              LEAVE_FF(fp->fs, FR_DENIED);
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 42  

              
                      remain = fp->fsize - fp->fptr;
                      if (btr > remain) btr = (UINT)remain;                   /* Truncate btr by remaining bytes */
              
                      for ( ;  btr && (*func)(NULL, 0);                               /* Repeat until all data transferred or stream becomes busy */
                              fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
                              if ((fp->fptr % SS(fp->fs)) == 0) {                     /* On the sector boundary? */
                                      if (fp->csect >= fp->fs->csize) {               /* On the cluster boundary? */
                                              clst = (fp->fptr == 0) ?                        /* On the top of the file? */
                                                      fp->org_clust : get_cluster(fp->fs, fp->curr_clust);
                                              if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
                                              if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
                                              fp->curr_clust = clst;                          /* Update current cluster */
                                              fp->csect = 0;                                          /* Reset sector address in the cluster */
                                      }
                                      fp->csect++;                                                    /* Next sector address in the cluster */
                              }
                              sect = clust2sect(fp->fs, fp->curr_clust);      /* Get current data sector */
                              if (!sect) ABORT(fp->fs, FR_INT_ERR);
                              sect += fp->csect - 1;
                              if (move_window(fp->fs, sect))                          /* Move sector window */
                                      ABORT(fp->fs, FR_DISK_ERR);
                              fp->dsect = sect;
                              rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));      /* Forward data from sector window */
                              if (rcnt > btr) rcnt = btr;
                              rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
                              if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
                      }
              
                      LEAVE_FF(fp->fs, FR_OK);
              }
              #endif /* _USE_FORWARD */
2559          
2560          
2561          
2562          #if _USE_MKFS && !_FS_READONLY
              /*-----------------------------------------------------------------------*/
              /* Create File System on the Drive                                       */
              /*-----------------------------------------------------------------------*/
              #define N_ROOTDIR       512                     /* Multiple of 32 and <= 2048 */
              #define N_FATS          1                       /* 1 or 2 */
              #define MAX_SECTOR      131072000UL     /* Maximum partition size */
              #define MIN_SECTOR      2000UL          /* Minimum partition size */
              
              
              FRESULT f_mkfs (
                      BYTE drv,                       /* Logical drive number */
                      BYTE partition,         /* Partitioning rule 0:FDISK, 1:SFD */
                      WORD allocsize          /* Allocation unit size [bytes] */
              )
              {
                      static const DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000, 4000,
             -   0 };
                      static const WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048, 1024,
             - 512 };
                      BYTE fmt, m, *tbl;
                      DWORD b_part, b_fat, b_dir, b_data;             /* Area offset (LBA) */
                      DWORD n_part, n_rsv, n_fat, n_dir;              /* Area size */
                      DWORD n_clst, n;
                      WORD as;
                      FATFS *fs;
                      DSTATUS stat;
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 43  

              
              
                      /* Check validity of the parameters */
                      if (drv >= _DRIVES) return FR_INVALID_DRIVE;
                      if (partition >= 2) return FR_MKFS_ABORTED;
              
                      /* Check mounted drive and clear work area */
                      fs = FatFs[drv];
                      if (!fs) return FR_NOT_ENABLED;
                      fs->fs_type = 0;
                      drv = LD2PD(drv);
              
                      /* Get disk statics */
                      stat = disk_initialize(drv);
                      if (stat & STA_NOINIT) return FR_NOT_READY;
                      if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
                      if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
                              return FR_MKFS_ABORTED;
                      if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
                      b_part = (!partition) ? 63 : 0;         /* Boot sector */
                      n_part -= b_part;
              #if _MAX_SS == 512
                      if (!allocsize) {                                       /* Auto selection of cluster size */
                              for (n = 0; n_part < sstbl[n]; n++) ;
                              allocsize = cstbl[n];
                      }
              #endif
                      for (as = 512; as <= 32768U && as != allocsize; as <<= 1);
                      if (as != allocsize) return FR_MKFS_ABORTED;
              #if _MAX_SS != 512                                              /* Check disk sector size */
                      if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
                              || SS(fs) > _MAX_SS
                              || SS(fs) > allocsize)
                              return FR_MKFS_ABORTED;
              #endif
                      allocsize /= SS(fs);            /* Number of sectors per cluster */
              
                      /* Pre-compute number of clusters and FAT type */
                      n_clst = n_part / allocsize;
                      fmt = FS_FAT12;
                      if (n_clst >= 0xFF5) fmt = FS_FAT16;
                      if (n_clst >= 0xFFF5) fmt = FS_FAT32;
              
                      /* Determine offset and size of FAT structure */
                      switch (fmt) {
                      case FS_FAT12:
                              n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
                              n_rsv = 1 + partition;
                              n_dir = N_ROOTDIR * 32 / SS(fs);
                              break;
                      case FS_FAT16:
                              n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
                              n_rsv = 1 + partition;
                              n_dir = N_ROOTDIR * 32 / SS(fs);
                              break;
                      default:
                              n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
                              n_rsv = 33 - partition;
                              n_dir = 0;
                      }
                      b_fat = b_part + n_rsv;                 /* FATs start sector */
                      b_dir = b_fat + n_fat * N_FATS; /* Directory start sector */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 44  

                      b_data = b_dir + n_dir;                 /* Data start sector */
              
                      /* Align data start sector to erase block boundary (for flash memory media) */
                      if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
                      n = (b_data + n - 1) & ~(n - 1);
                      n_fat += (n - b_data) / N_FATS;
                      /* b_dir and b_data are no longer used below */
              
                      /* Determine number of cluster and final check of validity of the FAT type */
                      n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
                      if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
                              || (fmt == FS_FAT32 && n_clst < 0xFFF5))
                              return FR_MKFS_ABORTED;
              
                      /* Create partition table if needed */
                      if (!partition) {
                              DWORD n_disk = b_part + n_part;
              
                              tbl = fs->win+MBR_Table;
                              ST_DWORD(tbl, 0x00010180);              /* Partition start in CHS */
                              if (n_disk < 63UL * 255 * 1024) {       /* Partition end in CHS */
                                      n_disk = n_disk / 63 / 255;
                                      tbl[7] = (BYTE)n_disk;
                                      tbl[6] = (BYTE)((n_disk >> 2) | 63);
                              } else {
                                      ST_WORD(&tbl[6], 0xFFFF);
                              }
                              tbl[5] = 254;
                              if (fmt != FS_FAT32)                    /* System ID */
                                      tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
                              else
                                      tbl[4] = 0x0c;
                              ST_DWORD(tbl+8, 63);                    /* Partition start in LBA */
                              ST_DWORD(tbl+12, n_part);               /* Partition size in LBA */
                              ST_WORD(tbl+64, 0xAA55);                /* Signature */
                              if (disk_write(drv, fs->win, 0, 1) != RES_OK)
                                      return FR_DISK_ERR;
                      }
              
                      /* Create boot record */
                      tbl = fs->win;                                                          /* Clear buffer */
                      mem_set(tbl, 0, SS(fs));
                      ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);                     /* Boot code (jmp $, nop) */
                      ST_WORD(tbl+BPB_BytsPerSec, SS(fs));            /* Sector size */
                      tbl[BPB_SecPerClus] = (BYTE)allocsize;          /* Sectors per cluster */
                      ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);                     /* Reserved sectors */
                      tbl[BPB_NumFATs] = N_FATS;                                      /* Number of FATs */
                      ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
                      if (n_part < 0x10000) {                                         /* Number of total sectors */
                              ST_WORD(tbl+BPB_TotSec16, n_part);
                      } else {
                              ST_DWORD(tbl+BPB_TotSec32, n_part);
                      }
                      tbl[BPB_Media] = 0xF8;                                          /* Media descripter */
                      ST_WORD(tbl+BPB_SecPerTrk, 63);                         /* Number of sectors per track */
                      ST_WORD(tbl+BPB_NumHeads, 255);                         /* Number of heads */
                      ST_DWORD(tbl+BPB_HiddSec, b_part);                      /* Hidden sectors */
                      n = get_fattime();                                                      /* Use current time as a VSN */
                      if (fmt != FS_FAT32) {
                              ST_DWORD(tbl+BS_VolID, n);                              /* Volume serial number */
                              ST_WORD(tbl+BPB_FATSz16, n_fat);                /* Number of secters per FAT */
                              tbl[BS_DrvNum] = 0x80;                                  /* Drive number */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 45  

                              tbl[BS_BootSig] = 0x29;                                 /* Extended boot signature */
                              mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);      /* Volume lavel, FAT signature */
                      } else {
                              ST_DWORD(tbl+BS_VolID32, n);                    /* Volume serial number */
                              ST_DWORD(tbl+BPB_FATSz32, n_fat);               /* Number of secters per FAT */
                              ST_DWORD(tbl+BPB_RootClus, 2);                  /* Root directory cluster (2) */
                              ST_WORD(tbl+BPB_FSInfo, 1);                             /* FSInfo record offset (bs+1) */
                              ST_WORD(tbl+BPB_BkBootSec, 6);                  /* Backup boot record offset (bs+6) */
                              tbl[BS_DrvNum32] = 0x80;                                /* Drive number */
                              tbl[BS_BootSig32] = 0x29;                               /* Extended boot signature */
                              mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);    /* Volume lavel, FAT signature */
                      }
                      ST_WORD(tbl+BS_55AA, 0xAA55);                           /* Signature */
                      if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
                              return FR_DISK_ERR;
                      if (fmt == FS_FAT32)
                              disk_write(drv, tbl, b_part+6, 1);
              
                      /* Initialize FAT area */
                      for (m = 0; m < N_FATS; m++) {
                              mem_set(tbl, 0, SS(fs));                /* 1st sector of the FAT  */
                              if (fmt != FS_FAT32) {
                                      n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
                                      ST_DWORD(tbl, n);                               /* Reserve cluster #0-1 (FAT12/16) */
                              } else {
                                      ST_DWORD(tbl+0, 0xFFFFFFF8);    /* Reserve cluster #0-1 (FAT32) */
                                      ST_DWORD(tbl+4, 0xFFFFFFFF);
                                      ST_DWORD(tbl+8, 0x0FFFFFFF);    /* Reserve cluster #2 for root dir */
                              }
                              if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
                                      return FR_DISK_ERR;
                              mem_set(tbl, 0, SS(fs));                /* Following FAT entries are filled by zero */
                              for (n = 1; n < n_fat; n++) {
                                      if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
                                              return FR_DISK_ERR;
                              }
                      }
              
                      /* Initialize Root directory */
                      m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
                      do {
                              if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
                                      return FR_DISK_ERR;
                      } while (--m);
              
                      /* Create FSInfo record if needed */
                      if (fmt == FS_FAT32) {
                              ST_WORD(tbl+BS_55AA, 0xAA55);
                              ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
                              ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
                              ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
                              ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
                              disk_write(drv, tbl, b_part+1, 1);
                              disk_write(drv, tbl, b_part+7, 1);
                      }
              
                      return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
              }
              
              #endif /* _USE_MKFS && !_FS_READONLY */
2771          
2772          
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 46  

2773          
2774          
2775          #if _USE_STRFUNC
              /*-----------------------------------------------------------------------*/
              /* Get a string from the file                                            */
              /*-----------------------------------------------------------------------*/
              char* f_gets (
                      char* buff,     /* Pointer to the string buffer to read */
                      int len,        /* Size of string buffer */
                      FIL* fil        /* Pointer to the file object */
              )
              {
                      int i = 0;
                      char *p = buff;
                      UINT rc;
              
              
                      while (i < len - 1) {                   /* Read bytes until buffer gets filled */
                              f_read(fil, p, 1, &rc);
                              if (rc != 1) break;                     /* Break when no data to read */
              #if _USE_STRFUNC >= 2
                              if (*p == '\r') continue;       /* Strip '\r' */
              #endif
                              i++;
                              if (*p++ == '\n') break;        /* Break when reached end of line */
                      }
                      *p = 0;
                      return i ? buff : NULL;                 /* When no data read (eof or error), return with error. */
              }
              
              
              
              #if !_FS_READONLY
              #include <stdarg.h>
              /*-----------------------------------------------------------------------*/
              /* Put a character to the file                                           */
              /*-----------------------------------------------------------------------*/
              int f_putc (
                      int chr,        /* A character to be output */
                      FIL* fil        /* Ponter to the file object */
              )
              {
                      UINT bw;
                      char c;
              
              
              #if _USE_STRFUNC >= 2
                      if (chr == '\n') f_putc ('\r', fil);    /* LF -> CRLF conversion */
              #endif
                      if (!fil) {     /* Special value may be used to switch the destination to any other device */
                      /*      put_console(chr);       */
                              return chr;
                      }
                      c = (char)chr;
                      f_write(fil, &c, 1, &bw);       /* Write a byte to the file */
                      return bw ? chr : EOF;          /* Return the result */
              }
              
              
              
              
              /*-----------------------------------------------------------------------*/
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 47  

              /* Put a string to the file                                              */
              /*-----------------------------------------------------------------------*/
              int f_puts (
                      const char* str,        /* Pointer to the string to be output */
                      FIL* fil                        /* Pointer to the file object */
              )
              {
                      int n;
              
              
                      for (n = 0; *str; str++, n++) {
                              if (f_putc(*str, fil) == EOF) return EOF;
                      }
                      return n;
              }
              
              
              
              
              /*-----------------------------------------------------------------------*/
              /* Put a formatted string to the file                                    */
              /*-----------------------------------------------------------------------*/
              int f_printf (
                      FIL* fil,                       /* Pointer to the file object */
                      const char* str,        /* Pointer to the format string */
                      ...                                     /* Optional arguments... */
              )
              {
                      va_list arp;
                      UCHAR c, f, r;
                      ULONG val;
                      char s[16];
                      int i, w, res, cc;
              
              
                      va_start(arp, str);
              
                      for (cc = res = 0; cc != EOF; res += cc) {
                              c = *str++;
                              if (c == 0) break;                      /* End of string */
                              if (c != '%') {                         /* Non escape cahracter */
                                      cc = f_putc(c, fil);
                                      if (cc != EOF) cc = 1;
                                      continue;
                              }
                              w = f = 0;
                              c = *str++;
                              if (c == '0') {                         /* Flag: '0' padding */
                                      f = 1; c = *str++;
                              }
                              while (c >= '0' && c <= '9') {  /* Precision */
                                      w = w * 10 + (c - '0');
                                      c = *str++;
                              }
                              if (c == 'l') {                         /* Prefix: Size is long int */
                                      f |= 2; c = *str++;
                              }
                              if (c == 's') {                         /* Type is string */
                                      cc = f_puts(va_arg(arp, char*), fil);
                                      continue;
                              }
                              if (c == 'c') {                         /* Type is character */
C51 COMPILER V9.06   FF                                                                    04/20/2012 16:19:00 PAGE 48  

                                      cc = f_putc(va_arg(arp, int), fil);
                                      if (cc != EOF) cc = 1;
                                      continue;
                              }
                              r = 0;
                              if (c == 'd') r = 10;           /* Type is signed decimal */
                              if (c == 'u') r = 10;           /* Type is unsigned decimal */
                              if (c == 'X') r = 16;           /* Type is unsigned hexdecimal */
                              if (r == 0) break;                      /* Unknown type */
                              if (f & 2) {                            /* Get the value */
                                      val = (ULONG)va_arg(arp, long);
                              } else {
                                      val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
                              }
                              /* Put numeral string */
                              if (c == 'd') {
                                      if (val & 0x80000000) {
                                              val = 0 - val;
                                              f |= 4;
                                      }
                              }
                              i = sizeof(s) - 1; s[i] = 0;
                              do {
                                      c = (UCHAR)(val % r + '0');
                                      if (c > '9') c += 7;
                                      s[--i] = c;
                                      val /= r;
                              } while (i && val);
                              if (i && (f & 4)) s[--i] = '-';
                              w = sizeof(s) - 1 - w;
                              while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
                              cc = f_puts(&s[i], fil);
                      }
              
                      va_end(arp);
                      return (cc == EOF) ? cc : res;
              }
              
              #endif /* !_FS_READONLY */
              #endif /* _USE_STRFUNC */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  23863    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =      5     851
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
